{
  "address": "0xfF2B7048d673767754B798df1702C786E2c59F1F",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_epochPeriod",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_routerGnosisToArb",
          "type": "address"
        },
        {
          "internalType": "contract IAMB",
          "name": "_amb",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_nodeData",
          "type": "bytes"
        }
      ],
      "name": "MessageSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "_count",
          "type": "uint64"
        }
      ],
      "name": "SnapshotSaved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_epochSent",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_ticketId",
          "type": "bytes32"
        }
      ],
      "name": "SnapshotSent",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "amb",
      "outputs": [
        {
          "internalType": "contract IAMB",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "epochPeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "inbox",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "routerGnosisToArb",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "saveSnapshot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "_fnSelector",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "sendMessage",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_epoch",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_inboxIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxSubmissionCost",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_excessFeeRefundAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxFeePerGas",
          "type": "uint256"
        }
      ],
      "name": "sendSnapshot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "ticketID",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "snapshots",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2ebd7f37e45d38d6a633271aa2b192413fff5d8d20a327cc1231a9674f3dee95",
  "receipt": {
    "to": null,
    "from": "0x407DDEC61d69b212498B140a26da70AE1C879f5a",
    "contractAddress": "0xfF2B7048d673767754B798df1702C786E2c59F1F",
    "transactionIndex": 1,
    "gasUsed": "613732",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc6003090e783398168db648588767047b1d901b940262424b70df81740f3bb83",
    "transactionHash": "0x2ebd7f37e45d38d6a633271aa2b192413fff5d8d20a327cc1231a9674f3dee95",
    "logs": [],
    "blockNumber": 4697843,
    "cumulativeGasUsed": "642300",
    "status": 1,
    "byzantium": true
  },
  "args": [
    7200,
    "0xF0492e87Be6d644A6a467fE20ee9EC5eFCB6cB23",
    "0x99Ca51a3534785ED619f46A79C7Ad65Fa8d85e7a"
  ],
  "numDeployments": 3,
  "solcInputHash": "916b5e2210e8e15d34b48798389f67fe",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochPeriod\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_routerGnosisToArb\",\"type\":\"address\"},{\"internalType\":\"contract IAMB\",\"name\":\"_amb\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_nodeData\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_count\",\"type\":\"uint64\"}],\"name\":\"SnapshotSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_epochSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_ticketId\",\"type\":\"bytes32\"}],\"name\":\"SnapshotSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"amb\",\"outputs\":[{\"internalType\":\"contract IAMB\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerGnosisToArb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saveSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inboxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFeePerGas\",\"type\":\"uint256\"}],\"name\":\"sendSnapshot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ticketID\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Vea Inbox From Gnosis to Arbitrum. Note: This contract is deployed on the Gnosis.\",\"events\":{\"MessageSent(bytes)\":{\"details\":\"Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.\",\"params\":{\"_nodeData\":\"The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, message), outbox relays to.call(message)\"}},\"SnapshotSaved(uint64)\":{\"params\":{\"_count\":\"The count of messages in the merkle tree.\"}},\"SnapshotSent(uint256,bytes32)\":{\"details\":\"The event is emitted when a snapshot is sent through the canonical arbitrum bridge.\",\"params\":{\"_epochSent\":\"The epoch of the snapshot.\",\"_ticketId\":\"The ticketId of the L2->L1 message.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor. Note: epochPeriod must match the VeaOutboxGnosisToArb contract deployment on Gnosis, since it's on a different chain, we can't read it and trust the deployer to set a correct value\",\"params\":{\"_amb\":\"The address of the AMB contract on Gnosis.\",\"_epochPeriod\":\"The duration in seconds between epochs.\",\"_routerGnosisToArb\":\"The router on Ethereum that routes from Gnosis to Arbitrum.\"}},\"saveSnapshot()\":{\"details\":\"Saves snapshot of state root. Snapshots can be saved a maximum of once per epoch.      `O(log(count))` where count number of messages in the inbox. Note: See merkle tree docs for details how inbox manages state.\"},\"sendMessage(address,bytes4,bytes)\":{\"details\":\"Sends an arbitrary message to Gnosis.      `O(log(count))` where count is the number of messages already sent.      Amortized cost is constant. Note: See merkle tree documentation for details how inbox manages state.\",\"params\":{\"_data\":\"The message calldata, abi.encode(param1, param2, ...)\",\"_fnSelector\":\"The function selector of the receiving contract.\",\"_to\":\"The address of the contract on the receiving chain which receives the calldata.\"},\"returns\":{\"_0\":\"msgId The zero based index of the message in the inbox.\"}},\"sendSnapshot(uint256,uint256,uint256,address,uint256,uint256)\":{\"details\":\"Sends the state root snapshot using Arbitrum's canonical bridge.\",\"params\":{\"_epoch\":\"The epoch of the snapshot requested to send.\",\"_excessFeeRefundAddress\":\"Address to refund any excess fee to\",\"_gasLimit\":\"Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\",\"_inboxIndex\":\"The index of the inbox in the Arbitrum bridge contract.\",\"_maxFeePerGas\":\"price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\",\"_maxSubmissionCost\":\"Max gas deducted from user's L2 balance to cover base submission fee\"}}},\"version\":1},\"userdoc\":{\"events\":{\"SnapshotSaved(uint64)\":{\"notice\":\"The bridgers can watch this event to claim the stateRoot on the veaOutbox.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/gnosisToArbitrum/VeaInboxGnosisToArb.sol\":\"VeaInboxGnosisToArb\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/canonical/gnosis-chain/IAMB.sol\":{\"content\":\"// https://docs.gnosischain.com/bridges/tokenbridge/amb-bridge#gnosis\\n// https://github.com/omni/tokenbridge-contracts/blob/908a48107919d4ab127f9af07d44d47eac91547e/contracts/interfaces/IAMB.sol\\n// interface is pruned for relevant function stubs\\n\\npragma solidity 0.8.18;\\n\\ninterface IAMB {\\n    function requireToPassMessage(address _contract, bytes memory _data, uint256 _gas) external returns (bytes32);\\n\\n    function maxGasPerTx() external view returns (uint256);\\n\\n    function messageSender() external view returns (address);\\n\\n    function messageSourceChainId() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x529d45e46ca0c046c32b296b35ae8073c4a999ef37510545ec44d26e78deca0d\"},\"src/gnosisToArbitrum/VeaInboxGnosisToArb.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// @custom:authors: [@jaybuidl, @shotaronowhere]\\n/// @custom:reviewers: []\\n/// @custom:auditors: []\\n/// @custom:bounties: []\\n/// @custom:deployments: []\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../canonical/gnosis-chain/IAMB.sol\\\";\\nimport \\\"../interfaces/inboxes/IVeaInbox.sol\\\";\\nimport \\\"../interfaces/routers/IRouterToArb.sol\\\";\\n\\n/// @dev Vea Inbox From Gnosis to Arbitrum.\\n/// Note: This contract is deployed on the Gnosis.\\ncontract VeaInboxGnosisToArb is IVeaInbox {\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    IAMB public immutable amb; // The address of the AMB contract on Gnosis.\\n\\n    uint256 public immutable epochPeriod; // Epochs mark the period between stateroot snapshots\\n    address public immutable routerGnosisToArb; // The router on Ethereum.\\n\\n    mapping(uint256 => bytes32) public snapshots; // epoch => state root snapshot\\n\\n    // Inbox represents minimum data availability to maintain incremental merkle tree.\\n    // Supports a max of 2^64 - 1 messages. See merkle tree docs for details how inbox manages state.\\n\\n    bytes32[64] public inbox; // stores minimal set of complete subtree roots of the merkle tree to increment.\\n    uint64 public count; // count of messages in the merkle tree\\n\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /// @dev Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.\\n    /// @param _nodeData The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, message), outbox relays to.call(message)\\n    event MessageSent(bytes _nodeData);\\n\\n    /// The bridgers can watch this event to claim the stateRoot on the veaOutbox.\\n    /// @param _count The count of messages in the merkle tree.\\n    event SnapshotSaved(uint64 _count);\\n\\n    /// @dev The event is emitted when a snapshot is sent through the canonical arbitrum bridge.\\n    /// @param _epochSent The epoch of the snapshot.\\n    /// @param _ticketId The ticketId of the L2->L1 message.\\n    event SnapshotSent(uint256 indexed _epochSent, bytes32 _ticketId);\\n\\n    /// @dev Constructor.\\n    /// Note: epochPeriod must match the VeaOutboxGnosisToArb contract deployment on Gnosis, since it's on a different chain, we can't read it and trust the deployer to set a correct value\\n    /// @param _epochPeriod The duration in seconds between epochs.\\n    /// @param _routerGnosisToArb The router on Ethereum that routes from Gnosis to Arbitrum.\\n    /// @param _amb The address of the AMB contract on Gnosis.\\n    constructor(uint256 _epochPeriod, address _routerGnosisToArb, IAMB _amb) {\\n        epochPeriod = _epochPeriod;\\n        routerGnosisToArb = _routerGnosisToArb;\\n        amb = _amb;\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /// @dev Sends an arbitrary message to Gnosis.\\n    ///      `O(log(count))` where count is the number of messages already sent.\\n    ///      Amortized cost is constant.\\n    /// Note: See merkle tree documentation for details how inbox manages state.\\n    /// @param _to The address of the contract on the receiving chain which receives the calldata.\\n    /// @param _fnSelector The function selector of the receiving contract.\\n    /// @param _data The message calldata, abi.encode(param1, param2, ...)\\n    /// @return msgId The zero based index of the message in the inbox.\\n    function sendMessage(address _to, bytes4 _fnSelector, bytes memory _data) external override returns (uint64) {\\n        uint64 oldCount = count;\\n\\n        // Given arbitrum's speed limit of 7 million gas / second, it would take atleast 8 million years of full blocks to overflow.\\n        // It *should* be impossible to overflow, but we check to be safe when appending to the tree.\\n        require(oldCount < type(uint64).max, \\\"Inbox is full.\\\");\\n\\n        bytes memory nodeData = abi.encodePacked(\\n            oldCount,\\n            _to,\\n            // data for outbox relay\\n            abi.encodePacked( // abi.encodeWithSelector(fnSelector, msg.sender, param1, param2, ...) where _data is abi.encode(param1, param2, ...)\\n                _fnSelector,\\n                bytes32(uint256(uint160(msg.sender))), // big endian padded encoding of msg.sender, simulating abi.encodeWithSelector\\n                _data\\n            )\\n        );\\n\\n        // single hashed leaf\\n        bytes32 newInboxNode = keccak256(nodeData);\\n\\n        // double hashed leaf\\n        // avoids second order preimage attacks\\n        // https://flawed.net.nz/2018/02/21/attacking-merkle-trees-with-a-second-preimage-attack/\\n        assembly {\\n            // efficient hash using EVM scratch space\\n            mstore(0x00, newInboxNode)\\n            newInboxNode := keccak256(0x00, 0x20)\\n        }\\n\\n        // increment merkle tree calculating minimal number of hashes\\n        unchecked {\\n            uint256 height;\\n\\n            // x = oldCount + 1; acts as a bit mask to determine if a hash is needed\\n            // note: x is always non-zero, and x is bit shifted to the right each loop\\n            // hence this loop will always terminate in a maximum of log_2(oldCount + 1) iterations\\n            for (uint64 x = oldCount + 1; x & 1 == 0; x = x >> 1) {\\n                // sort sibling hashes as a convention for efficient proof validation\\n                newInboxNode = sortConcatAndHash(inbox[height], newInboxNode);\\n                height++;\\n            }\\n\\n            inbox[height] = newInboxNode;\\n\\n            // finally increment count\\n            count = oldCount + 1;\\n        }\\n\\n        emit MessageSent(nodeData);\\n\\n        // old count is the zero indexed leaf position in the tree, acts as a msgId\\n        // gateways should index these msgIds to later relay proofs\\n        return oldCount;\\n    }\\n\\n    /// @dev Saves snapshot of state root. Snapshots can be saved a maximum of once per epoch.\\n    ///      `O(log(count))` where count number of messages in the inbox.\\n    /// Note: See merkle tree docs for details how inbox manages state.\\n    function saveSnapshot() external {\\n        uint256 epoch;\\n        bytes32 stateRoot;\\n\\n        unchecked {\\n            epoch = block.timestamp / epochPeriod;\\n\\n            // calculate the current root of the incremental merkle tree encoded in the inbox\\n\\n            uint256 height;\\n\\n            // x acts as a bit mask to determine if the hash stored in the inbox contributes to the root\\n            uint256 x;\\n\\n            // x is bit shifted to the right each loop, hence this loop will always terminate in a maximum of log_2(count) iterations\\n            for (x = uint256(count); x > 0; x = x >> 1) {\\n                if ((x & 1) == 1) {\\n                    // first hash is special case\\n                    // inbox stores the root of complete subtrees\\n                    // eg if count = 4 = 0b100, then the first complete subtree is inbox[2]\\n                    // inbox = [H(3), H(1,2), H(1,4)], we read inbox[2] directly\\n\\n                    stateRoot = inbox[height];\\n                    break;\\n                }\\n                height++;\\n            }\\n\\n            // after the first hash, we can calculate the root incrementally\\n            for (x = x >> 1; x > 0; x = x >> 1) {\\n                height++;\\n                if ((x & 1) == 1) {\\n                    // sort sibling hashes as a convention for efficient proof validation\\n                    stateRoot = sortConcatAndHash(inbox[height], stateRoot);\\n                }\\n            }\\n        }\\n\\n        snapshots[epoch] = stateRoot;\\n\\n        emit SnapshotSaved(count);\\n    }\\n\\n    /// @dev Helper function to calculate merkle tree interior nodes by sorting and concatenating and hashing a pair of children nodes, left and right.\\n    /// Note: EVM scratch space is used to efficiently calculate hashes.\\n    /// @param _left The left hash.\\n    /// @param _right The right hash.\\n    /// @return parent The parent hash.\\n    function sortConcatAndHash(bytes32 _left, bytes32 _right) internal pure returns (bytes32 parent) {\\n        // sort sibling hashes as a convention for efficient proof validation\\n        if (_left < _right) {\\n            // efficient hash using EVM scratch space\\n            assembly {\\n                mstore(0x00, _left)\\n                mstore(0x20, _right)\\n                parent := keccak256(0x00, 0x40)\\n            }\\n        } else {\\n            assembly {\\n                mstore(0x00, _right)\\n                mstore(0x20, _left)\\n                parent := keccak256(0x00, 0x40)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends the state root snapshot using Arbitrum's canonical bridge.\\n    /// @param _epoch The epoch of the snapshot requested to send.\\n    /// @param _inboxIndex The index of the inbox in the Arbitrum bridge contract.\\n    /// @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n    /// @param _excessFeeRefundAddress Address to refund any excess fee to\\n    /// @param _gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n    /// @param _maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n    function sendSnapshot(\\n        uint256 _epoch,\\n        uint256 _inboxIndex,\\n        uint256 _maxSubmissionCost,\\n        address _excessFeeRefundAddress,\\n        uint256 _gasLimit,\\n        uint256 _maxFeePerGas\\n    ) external virtual returns (bytes32 ticketID) {\\n        unchecked {\\n            require(_epoch < block.timestamp / epochPeriod, \\\"Can only send past epoch snapshot.\\\");\\n        }\\n\\n        bytes memory data = abi.encodeCall(\\n            IRouterToArb.route,\\n            (\\n                _epoch,\\n                snapshots[_epoch],\\n                _inboxIndex,\\n                _maxSubmissionCost,\\n                _excessFeeRefundAddress,\\n                _gasLimit,\\n                _maxFeePerGas\\n            )\\n        );\\n        // Note: using maxGasPerTx here means the relaying txn on Gnosis will need to pass that (large) amount of gas, though almost all will be unused and refunded. This is preferred over hardcoding a gas limit.\\n        ticketID = amb.requireToPassMessage(routerGnosisToArb, data, amb.maxGasPerTx());\\n\\n        emit SnapshotSent(_epoch, ticketID);\\n    }\\n}\\n\",\"keccak256\":\"0x0125442dc06bc061fc1c6a3719018904fcc92db68696f93ea4bf770a4da66b15\",\"license\":\"MIT\"},\"src/interfaces/inboxes/IVeaInbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// @custom:authors: [@jaybuidl, @shotaronowhere]\\n/// @custom:reviewers: []\\n/// @custom:auditors: []\\n/// @custom:bounties: []\\n/// @custom:deployments: []\\n\\npragma solidity 0.8.18;\\n\\ninterface IVeaInbox {\\n    /// @dev Sends an arbitrary message to receiving chain.\\n    /// Note: Calls authenticated by receiving gateway checking the sender argument.\\n    /// @param _to The cross-domain contract address which receives the calldata.\\n    /// @param _fnSelection The function selector of the receiving contract.\\n    /// @param _data The message calldata, abi.encode(...)\\n    /// @return msgId The index of the message in the inbox, as a message Id, needed to relay the message.\\n    function sendMessage(address _to, bytes4 _fnSelection, bytes memory _data) external returns (uint64 msgId);\\n\\n    /// @dev Snapshots can be saved a maximum of once per epoch.\\n    ///      Saves snapshot of state root.\\n    ///      `O(log(count))` where count number of messages in the inbox.\\n    function saveSnapshot() external;\\n}\\n\",\"keccak256\":\"0x053799bf55019a7f1db4cd889ce83cbe7319e832eec0234b1d4020a2aa0026f9\",\"license\":\"MIT\"},\"src/interfaces/routers/IRouterToArb.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// @custom:authors: [@shotaronowhere]\\n/// @custom:reviewers: []\\n/// @custom:auditors: []\\n/// @custom:bounties: []\\n/// @custom:deployments: []\\n\\npragma solidity 0.8.18;\\n\\n/// @dev Interface of the Vea Router intended to be deployed on an intermediary chain which routes messages to Arbitrum where calldata is the primary cost.\\n///      eg. Gnosis (L1) -> Ethereum (L1) -> Arbitrum (L2), the IRouterToL2 will be deployed on Ethereum (L1) routing messages to Arbitrum (L2).\\ninterface IRouterToArb {\\n    /// @dev Resolves any challenge of the optimistic claim for 'epoch' using the canonical bridge.\\n    /// Note: Access restricted to canonical sending-chain bridge.\\n    /// @param _epoch The epoch to verify.\\n    /// @param _stateroot The true state root for the epoch.\\n    /// @param _inboxIndex The index of the inbox in the Arbitrum bridge contract.\\n    /// @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n    /// @param _excessFeeRefundAddress Address to refund any excess fee to\\n    /// @param _gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n    /// @param _maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n    function route(\\n        uint256 _epoch,\\n        bytes32 _stateroot,\\n        uint256 _inboxIndex,\\n        uint256 _maxSubmissionCost,\\n        address _excessFeeRefundAddress,\\n        uint256 _gasLimit,\\n        uint256 _maxFeePerGas\\n    ) external;\\n}\\n\",\"keccak256\":\"0xc265211871b748c9191df4fd6419d57abf030314ee5ef7aa89f14a863521f174\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e060405234801561001057600080fd5b50604051610b0b380380610b0b83398101604081905261002f91610064565b60a0929092526001600160a01b0390811660c052166080526100a7565b6001600160a01b038116811461006157600080fd5b50565b60008060006060848603121561007957600080fd5b83519250602084015161008b8161004c565b604085015190925061009c8161004c565b809150509250925092565b60805160a05160c051610a1a6100f1600039600081816101a6015261031701526000818161014c015281816101cc015261043301526000818160cf01526102ee0152610a1a6000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c80635f85896c116100665780635f85896c14610134578063b5b7a18414610147578063d6565a2d1461016e578063e5a1c3561461018e578063eb8dedfa146101a157600080fd5b806306661abd146100985780631062b39a146100ca5780632bbb470414610109578063519205351461012a575b600080fd5b6041546100ac9067ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b6100f17f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100c1565b61011c61011736600461071b565b6101c8565b6040519081526020016100c1565b61013261042e565b005b6100ac610142366004610782565b610548565b61011c7f000000000000000000000000000000000000000000000000000000000000000081565b61011c61017c366004610863565b60006020819052908152604090205481565b61011c61019c366004610863565b6106b4565b6100f17f000000000000000000000000000000000000000000000000000000000000000081565b60007f000000000000000000000000000000000000000000000000000000000000000042816101f9576101f961087c565b0487106102585760405162461bcd60e51b815260206004820152602260248201527f43616e206f6e6c792073656e6420706173742065706f636820736e617073686f6044820152613a1760f11b60648201526084015b60405180910390fd5b600087815260208190526040808220549051602481018a9052604481019190915260648101889052608481018790526001600160a01b03861660a482015260c4810185905260e481018490526101040160408051601f19818403018152918152602080830180516001600160e01b031663507b5ad360e01b179052815163e5789d0360e01b815291519293506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169263dc8601b3927f0000000000000000000000000000000000000000000000000000000000000000928692869263e5789d039260048083019391928290030181865afa158015610362573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103869190610892565b6040518463ffffffff1660e01b81526004016103a4939291906108fb565b6020604051808303816000875af11580156103c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103e79190610892565b9150877f6fdd49f435101fc7b6ebdec7c8972932a926d18f6cb78a8891dfe950743b6b828360405161041b91815260200190565b60405180910390a2509695505050505050565b6000807f000000000000000000000000000000000000000000000000000000000000000042816104605761046061087c565b604154919004925060009067ffffffffffffffff165b80156104af57806001166001036104a3576001826040811061049a5761049a61092f565b015492506104af565b6001918201911c610476565b60011c5b80156104f15760019182019181811690036104e9576104e6600183604081106104de576104de61092f565b0154846106cb565b92505b60011c6104b3565b505060008281526020818152604091829020839055604154915167ffffffffffffffff90921682527f8d762ebc760982a11d9a00cc7c1c4c91f9c1084b85633ee8ca462da42465f1d9910160405180910390a15050565b60415460009067ffffffffffffffff90811690811061059a5760405162461bcd60e51b815260206004820152600e60248201526d24b73137bc1034b990333ab6361760911b604482015260640161024f565b604051600090829087906105b690889033908990602001610945565b60408051601f19818403018152908290526105d593929160200161097b565b60408051601f1981840301815291905280516020808301919091206000908152908120919250600184015b6001811660000361063957610621600183604081106104de576104de61092f565b92506001918201911c677fffffffffffffff16610600565b50816001826040811061064e5761064e61092f565b0155506041805467ffffffffffffffff19166001850167ffffffffffffffff161790556040517f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036906106a19084906109ca565b60405180910390a1509095945050505050565b600181604081106106c457600080fd5b0154905081565b6000818310156106e9578260005281602052604060002090506106f9565b8160005282602052604060002090505b92915050565b80356001600160a01b038116811461071657600080fd5b919050565b60008060008060008060c0878903121561073457600080fd5b863595506020870135945060408701359350610752606088016106ff565b92506080870135915060a087013590509295509295509295565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561079757600080fd5b6107a0846106ff565b925060208401356001600160e01b0319811681146107bd57600080fd5b9150604084013567ffffffffffffffff808211156107da57600080fd5b818601915086601f8301126107ee57600080fd5b8135818111156108005761080061076c565b604051601f8201601f19908116603f011681019083821181831017156108285761082861076c565b8160405282815289602084870101111561084157600080fd5b8260208601602083013760006020848301015280955050505050509250925092565b60006020828403121561087557600080fd5b5035919050565b634e487b7160e01b600052601260045260246000fd5b6000602082840312156108a457600080fd5b5051919050565b60005b838110156108c65781810151838201526020016108ae565b50506000910152565b600081518084526108e78160208601602086016108ab565b601f01601f19169290920160200192915050565b6001600160a01b038416815260606020820181905260009061091f908301856108cf565b9050826040830152949350505050565b634e487b7160e01b600052603260045260246000fd5b63ffffffff60e01b841681528260048201526000825161096c8160248501602087016108ab565b91909101602401949350505050565b67ffffffffffffffff60c01b8460c01b1681526bffffffffffffffffffffffff198360601b166008820152600082516109bb81601c8501602087016108ab565b91909101601c01949350505050565b6020815260006109dd60208301846108cf565b939250505056fea2646970667358221220f154e7c06a230a8584c6b8ca63e2df548a849b848ce8e10ae47300e98e2f281164736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c80635f85896c116100665780635f85896c14610134578063b5b7a18414610147578063d6565a2d1461016e578063e5a1c3561461018e578063eb8dedfa146101a157600080fd5b806306661abd146100985780631062b39a146100ca5780632bbb470414610109578063519205351461012a575b600080fd5b6041546100ac9067ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b6100f17f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100c1565b61011c61011736600461071b565b6101c8565b6040519081526020016100c1565b61013261042e565b005b6100ac610142366004610782565b610548565b61011c7f000000000000000000000000000000000000000000000000000000000000000081565b61011c61017c366004610863565b60006020819052908152604090205481565b61011c61019c366004610863565b6106b4565b6100f17f000000000000000000000000000000000000000000000000000000000000000081565b60007f000000000000000000000000000000000000000000000000000000000000000042816101f9576101f961087c565b0487106102585760405162461bcd60e51b815260206004820152602260248201527f43616e206f6e6c792073656e6420706173742065706f636820736e617073686f6044820152613a1760f11b60648201526084015b60405180910390fd5b600087815260208190526040808220549051602481018a9052604481019190915260648101889052608481018790526001600160a01b03861660a482015260c4810185905260e481018490526101040160408051601f19818403018152918152602080830180516001600160e01b031663507b5ad360e01b179052815163e5789d0360e01b815291519293506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169263dc8601b3927f0000000000000000000000000000000000000000000000000000000000000000928692869263e5789d039260048083019391928290030181865afa158015610362573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103869190610892565b6040518463ffffffff1660e01b81526004016103a4939291906108fb565b6020604051808303816000875af11580156103c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103e79190610892565b9150877f6fdd49f435101fc7b6ebdec7c8972932a926d18f6cb78a8891dfe950743b6b828360405161041b91815260200190565b60405180910390a2509695505050505050565b6000807f000000000000000000000000000000000000000000000000000000000000000042816104605761046061087c565b604154919004925060009067ffffffffffffffff165b80156104af57806001166001036104a3576001826040811061049a5761049a61092f565b015492506104af565b6001918201911c610476565b60011c5b80156104f15760019182019181811690036104e9576104e6600183604081106104de576104de61092f565b0154846106cb565b92505b60011c6104b3565b505060008281526020818152604091829020839055604154915167ffffffffffffffff90921682527f8d762ebc760982a11d9a00cc7c1c4c91f9c1084b85633ee8ca462da42465f1d9910160405180910390a15050565b60415460009067ffffffffffffffff90811690811061059a5760405162461bcd60e51b815260206004820152600e60248201526d24b73137bc1034b990333ab6361760911b604482015260640161024f565b604051600090829087906105b690889033908990602001610945565b60408051601f19818403018152908290526105d593929160200161097b565b60408051601f1981840301815291905280516020808301919091206000908152908120919250600184015b6001811660000361063957610621600183604081106104de576104de61092f565b92506001918201911c677fffffffffffffff16610600565b50816001826040811061064e5761064e61092f565b0155506041805467ffffffffffffffff19166001850167ffffffffffffffff161790556040517f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036906106a19084906109ca565b60405180910390a1509095945050505050565b600181604081106106c457600080fd5b0154905081565b6000818310156106e9578260005281602052604060002090506106f9565b8160005282602052604060002090505b92915050565b80356001600160a01b038116811461071657600080fd5b919050565b60008060008060008060c0878903121561073457600080fd5b863595506020870135945060408701359350610752606088016106ff565b92506080870135915060a087013590509295509295509295565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561079757600080fd5b6107a0846106ff565b925060208401356001600160e01b0319811681146107bd57600080fd5b9150604084013567ffffffffffffffff808211156107da57600080fd5b818601915086601f8301126107ee57600080fd5b8135818111156108005761080061076c565b604051601f8201601f19908116603f011681019083821181831017156108285761082861076c565b8160405282815289602084870101111561084157600080fd5b8260208601602083013760006020848301015280955050505050509250925092565b60006020828403121561087557600080fd5b5035919050565b634e487b7160e01b600052601260045260246000fd5b6000602082840312156108a457600080fd5b5051919050565b60005b838110156108c65781810151838201526020016108ae565b50506000910152565b600081518084526108e78160208601602086016108ab565b601f01601f19169290920160200192915050565b6001600160a01b038416815260606020820181905260009061091f908301856108cf565b9050826040830152949350505050565b634e487b7160e01b600052603260045260246000fd5b63ffffffff60e01b841681528260048201526000825161096c8160248501602087016108ab565b91909101602401949350505050565b67ffffffffffffffff60c01b8460c01b1681526bffffffffffffffffffffffff198360601b166008820152600082516109bb81601c8501602087016108ab565b91909101601c01949350505050565b6020815260006109dd60208301846108cf565b939250505056fea2646970667358221220f154e7c06a230a8584c6b8ca63e2df548a849b848ce8e10ae47300e98e2f281164736f6c63430008120033",
  "devdoc": {
    "details": "Vea Inbox From Gnosis to Arbitrum. Note: This contract is deployed on the Gnosis.",
    "events": {
      "MessageSent(bytes)": {
        "details": "Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.",
        "params": {
          "_nodeData": "The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, message), outbox relays to.call(message)"
        }
      },
      "SnapshotSaved(uint64)": {
        "params": {
          "_count": "The count of messages in the merkle tree."
        }
      },
      "SnapshotSent(uint256,bytes32)": {
        "details": "The event is emitted when a snapshot is sent through the canonical arbitrum bridge.",
        "params": {
          "_epochSent": "The epoch of the snapshot.",
          "_ticketId": "The ticketId of the L2->L1 message."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor. Note: epochPeriod must match the VeaOutboxGnosisToArb contract deployment on Gnosis, since it's on a different chain, we can't read it and trust the deployer to set a correct value",
        "params": {
          "_amb": "The address of the AMB contract on Gnosis.",
          "_epochPeriod": "The duration in seconds between epochs.",
          "_routerGnosisToArb": "The router on Ethereum that routes from Gnosis to Arbitrum."
        }
      },
      "saveSnapshot()": {
        "details": "Saves snapshot of state root. Snapshots can be saved a maximum of once per epoch.      `O(log(count))` where count number of messages in the inbox. Note: See merkle tree docs for details how inbox manages state."
      },
      "sendMessage(address,bytes4,bytes)": {
        "details": "Sends an arbitrary message to Gnosis.      `O(log(count))` where count is the number of messages already sent.      Amortized cost is constant. Note: See merkle tree documentation for details how inbox manages state.",
        "params": {
          "_data": "The message calldata, abi.encode(param1, param2, ...)",
          "_fnSelector": "The function selector of the receiving contract.",
          "_to": "The address of the contract on the receiving chain which receives the calldata."
        },
        "returns": {
          "_0": "msgId The zero based index of the message in the inbox."
        }
      },
      "sendSnapshot(uint256,uint256,uint256,address,uint256,uint256)": {
        "details": "Sends the state root snapshot using Arbitrum's canonical bridge.",
        "params": {
          "_epoch": "The epoch of the snapshot requested to send.",
          "_excessFeeRefundAddress": "Address to refund any excess fee to",
          "_gasLimit": "Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)",
          "_inboxIndex": "The index of the inbox in the Arbitrum bridge contract.",
          "_maxFeePerGas": "price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)",
          "_maxSubmissionCost": "Max gas deducted from user's L2 balance to cover base submission fee"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "SnapshotSaved(uint64)": {
        "notice": "The bridgers can watch this event to claim the stateRoot on the veaOutbox."
      }
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5767,
        "contract": "src/gnosisToArbitrum/VeaInboxGnosisToArb.sol:VeaInboxGnosisToArb",
        "label": "snapshots",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_bytes32)"
      },
      {
        "astId": 5771,
        "contract": "src/gnosisToArbitrum/VeaInboxGnosisToArb.sol:VeaInboxGnosisToArb",
        "label": "inbox",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_bytes32)64_storage"
      },
      {
        "astId": 5773,
        "contract": "src/gnosisToArbitrum/VeaInboxGnosisToArb.sol:VeaInboxGnosisToArb",
        "label": "count",
        "offset": 0,
        "slot": "65",
        "type": "t_uint64"
      }
    ],
    "types": {
      "t_array(t_bytes32)64_storage": {
        "base": "t_bytes32",
        "encoding": "inplace",
        "label": "bytes32[64]",
        "numberOfBytes": "2048"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}
