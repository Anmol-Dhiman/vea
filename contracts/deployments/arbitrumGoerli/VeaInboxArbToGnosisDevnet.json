{
  "address": "0x9C7c2D9276E6C543960943C82f12Ff952B937F46",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_epochPeriod",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_routerArbToGnosis",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "nodeData",
          "type": "bytes"
        }
      ],
      "name": "MessageSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "count",
          "type": "uint64"
        }
      ],
      "name": "SnapshotSaved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochSent",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "ticketId",
          "type": "bytes32"
        }
      ],
      "name": "SnapshotSent",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "epochPeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "inbox",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "routerArbToGnosis",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "saveSnapshot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "fnSelector",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "sendMessage",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "epoch",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "stateRoot",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "claimer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "blocknumber",
              "type": "uint32"
            },
            {
              "internalType": "enum Party",
              "name": "honest",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "challenger",
              "type": "address"
            }
          ],
          "internalType": "struct Claim",
          "name": "claim",
          "type": "tuple"
        }
      ],
      "name": "sendSnapshot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "snapshots",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x691d9f495231cdd0ec1d79809df7f99672474c952565eb9ea6410e3f8fbd78ab",
  "receipt": {
    "to": null,
    "from": "0x407DDEC61d69b212498B140a26da70AE1C879f5a",
    "contractAddress": "0x9C7c2D9276E6C543960943C82f12Ff952B937F46",
    "transactionIndex": 1,
    "gasUsed": "648871",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x733d5fd9cd9ef77b98fdf33f185401eaf6fd49b90a3a48fcb7a95665316d2c0f",
    "transactionHash": "0x691d9f495231cdd0ec1d79809df7f99672474c952565eb9ea6410e3f8fbd78ab",
    "logs": [],
    "blockNumber": 21396208,
    "cumulativeGasUsed": "648871",
    "status": 1,
    "byzantium": true
  },
  "args": [
    1800,
    "0x169838Ae4272b68B702b36CeEF5f36a4B7B18A3F"
  ],
  "numDeployments": 7,
  "solcInputHash": "c969dbb068abf4957098c008212d1a0e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochPeriod\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_routerArbToGnosis\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"nodeData\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"}],\"name\":\"SnapshotSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ticketId\",\"type\":\"bytes32\"}],\"name\":\"SnapshotSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerArbToGnosis\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saveSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blocknumber\",\"type\":\"uint32\"},{\"internalType\":\"enum Party\",\"name\":\"honest\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"internalType\":\"struct Claim\",\"name\":\"claim\",\"type\":\"tuple\"}],\"name\":\"sendSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"MessageSent(bytes)\":{\"details\":\"Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.\",\"params\":{\"nodeData\":\"The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, message), outbox relays to.call(message)\"}},\"SnapshotSaved(uint64)\":{\"params\":{\"count\":\"The count of messages in the merkle tree.\"}},\"SnapshotSent(uint256,bytes32)\":{\"details\":\"The event is emitted when a snapshot is sent through the canonical arbitrum bridge.\",\"params\":{\"epochSent\":\"The epoch of the snapshot.\",\"ticketId\":\"The ticketId of the L2->L1 message.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor. Note: epochPeriod must match the VeaOutboxArbToGnosis contract deployment on Gnosis, since it's on a different chain, we can't read it and trust the deployer to set a correct value\",\"params\":{\"_epochPeriod\":\"The duration in seconds between epochs.\",\"_routerArbToGnosis\":\"The router on Ethereum that routes from Arbitrum to Gnosis.\"}},\"saveSnapshot()\":{\"details\":\"Saves snapshot of state root. Snapshots can be saved a maximum of once per epoch. `O(log(count))` where count number of messages in the inbox. Note: See merkle tree docs for details how inbox manages state.\"},\"sendMessage(address,bytes4,bytes)\":{\"details\":\"Sends an arbitrary message to Gnosis. `O(log(count))` where count is the number of messages already sent. Amortized cost is constant. Note: See merkle tree documentation for details how inbox manages state.\",\"params\":{\"data\":\"The message calldata, abi.encode(param1, param2, ...)\",\"fnSelector\":\"The function selector of the receiving contract.\",\"to\":\"The address of the contract on the receiving chain which receives the calldata.\"},\"returns\":{\"_0\":\"msgId The zero based index of the message in the inbox.\"}},\"sendSnapshot(uint256,(bytes32,address,uint32,uint32,uint8,address))\":{\"details\":\"Sends the state root snapshot using Arbitrum's canonical bridge.\",\"params\":{\"claim\":\"The claim associated with the epoch\",\"epoch\":\"The epoch of the snapshot requested to send.\"}}},\"version\":1},\"userdoc\":{\"events\":{\"SnapshotSaved(uint64)\":{\"notice\":\"The bridgers can watch this event to claim the stateRoot on the veaOutbox.\"}},\"kind\":\"user\",\"methods\":{},\"notice\":\"Vea Inbox From Arbitrum to Gnosis. Note: This contract is deployed on the Arbitrum.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/arbitrumToGnosis/VeaInboxArbToGnosis.sol\":\"VeaInboxArbToGnosis\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/arbitrumToGnosis/VeaInboxArbToGnosis.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@jaybuidl, @shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../canonical/arbitrum/IArbSys.sol\\\";\\nimport \\\"../interfaces/inboxes/IVeaInbox.sol\\\";\\nimport \\\"../interfaces/routers/IRouterToL1.sol\\\";\\n\\n/**\\n * Vea Inbox From Arbitrum to Gnosis.\\n * Note: This contract is deployed on the Arbitrum.\\n */\\ncontract VeaInboxArbToGnosis is IVeaInbox {\\n    // ************************************* //\\n    // *             Storage               * //\\n    // ************************************* //\\n\\n    // Arbitrum precompile ArbSys for L2->L1 messaging: https://developer.arbitrum.io/arbos/precompiles#arbsys\\n    IArbSys internal constant ARB_SYS = IArbSys(address(100));\\n\\n    uint256 public immutable epochPeriod; // Epochs mark the period between stateroot snapshots\\n    address public immutable routerArbToGnosis; // The router on ethereum.\\n\\n    mapping(uint256 => bytes32) public snapshots; // epoch => state root snapshot\\n\\n    // Inbox represents minimum data availability to maintain incremental merkle tree.\\n    // Supports a max of 2^64 - 1 messages. See merkle tree docs for details how inbox manages state.\\n\\n\\n    bytes32[64] public inbox; // stores minimal set of complete subtree roots of the merkle tree to increment.\\n    uint64 public count; // count of messages in the merkle tree\\n\\n    // ************************************* //\\n    // *              Events               * //\\n    // ************************************* //\\n\\n    /**\\n     * @dev Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.\\n     * @param nodeData The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, message), outbox relays to.call(message)\\n     */\\n    event MessageSent(bytes nodeData);\\n\\n    /**\\n     * The bridgers can watch this event to claim the stateRoot on the veaOutbox.\\n     * @param count The count of messages in the merkle tree.\\n     */\\n    event SnapshotSaved(uint64 count);\\n\\n    /**\\n     * @dev The event is emitted when a snapshot is sent through the canonical arbitrum bridge.\\n     * @param epochSent The epoch of the snapshot.\\n     * @param ticketId The ticketId of the L2->L1 message.\\n     */\\n    event SnapshotSent(uint256 indexed epochSent, bytes32 ticketId);\\n\\n    /**\\n     * @dev Constructor.\\n     * Note: epochPeriod must match the VeaOutboxArbToGnosis contract deployment on Gnosis, since it's on a different chain, we can't read it and trust the deployer to set a correct value\\n     * @param _epochPeriod The duration in seconds between epochs.\\n     * @param _routerArbToGnosis The router on Ethereum that routes from Arbitrum to Gnosis.\\n     */\\n    constructor(uint256 _epochPeriod, address _routerArbToGnosis) {\\n        epochPeriod = _epochPeriod;\\n        routerArbToGnosis = _routerArbToGnosis;\\n\\n        // epochPeriod should never be set this small, but we check non-zero value as a sanity check to avoid division by zero\\n        require(_epochPeriod > 0, \\\"Epoch period must be greater than 0.\\\");\\n    }\\n\\n    // ************************************* //\\n    // *         State Modifiers           * //\\n    // ************************************* //\\n\\n    /**\\n     * @dev Sends an arbitrary message to Gnosis.\\n     * `O(log(count))` where count is the number of messages already sent.\\n     * Amortized cost is constant.\\n     * Note: See merkle tree documentation for details how inbox manages state.\\n     * @param to The address of the contract on the receiving chain which receives the calldata.\\n     * @param fnSelector The function selector of the receiving contract.\\n     * @param data The message calldata, abi.encode(param1, param2, ...)\\n     * @return msgId The zero based index of the message in the inbox.\\n     */\\n    function sendMessage(address to, bytes4 fnSelector, bytes memory data) external override returns (uint64) {\\n        uint64 oldCount = count;\\n\\n        // Given arbitrum's speed limit of 7 million gas / second, it would take atleast 8 million years of full blocks to overflow.\\n        // It *should* be impossible to overflow, but we check to be safe when appending to the tree.\\n        require(oldCount < type(uint64).max, \\\"Inbox is full.\\\");\\n\\n        bytes memory nodeData = abi.encodePacked(\\n            oldCount,\\n            to,\\n            // data for outbox relay\\n            abi.encodePacked( // abi.encodeWithSelector(fnSelector, msg.sender, data)\\n                fnSelector,\\n                bytes32(uint256(uint160(msg.sender))), // big endian padded encoding of msg.sender, simulating abi.encodeWithSelector\\n                data\\n            )\\n        );\\n\\n        // single hashed leaf\\n        bytes32 newInboxNode = keccak256(nodeData);\\n\\n        // double hashed leaf\\n        // avoids second order preimage attacks\\n        // https://flawed.net.nz/2018/02/21/attacking-merkle-trees-with-a-second-preimage-attack/\\n        assembly {\\n            // efficient hash using EVM scratch space\\n            mstore(0x00, newInboxNode)\\n            newInboxNode := keccak256(0x00, 0x20)\\n        }\\n\\n        // increment merkle tree calculating minimal number of hashes\\n        unchecked {\\n            uint256 height;\\n\\n            // x = oldCount + 1; acts as a bit mask to determine if a hash is needed\\n            // note: x is always non-zero, and x is bit shifted to the right each loop\\n            // hence this loop will always terminate in a maximum of log_2(oldCount + 1) iterations\\n            for (uint64 x = oldCount + 1; x & 1 == 0; x = x >> 1) {\\n                // sort sibling hashes as a convention for efficient proof validation\\n                newInboxNode = sortConcatAndHash(inbox[height], newInboxNode);\\n                height++;\\n            }\\n\\n            inbox[height] = newInboxNode;\\n\\n            // finally increment count\\n            count = oldCount + 1;\\n        }\\n\\n        emit MessageSent(nodeData);\\n\\n        // old count is the zero indexed leaf position in the tree, acts as a msgId\\n        // gateways should index these msgIds to later relay proofs\\n        return oldCount;\\n    }\\n\\n    /**\\n     * @dev Saves snapshot of state root. Snapshots can be saved a maximum of once per epoch.\\n     * `O(log(count))` where count number of messages in the inbox.\\n     * Note: See merkle tree docs for details how inbox manages state.\\n     */\\n    function saveSnapshot() external {\\n        uint256 epoch;\\n        bytes32 stateRoot;\\n\\n        unchecked {\\n            epoch = block.timestamp / epochPeriod;\\n\\n            require(snapshots[epoch] == bytes32(0), \\\"Snapshot already taken for this epoch.\\\");\\n\\n            // calculate the current root of the incremental merkle tree encoded in the inbox\\n\\n            uint256 height;\\n\\n            // x acts as a bit mask to determine if the hash stored in the inbox contributes to the root\\n            uint256 x;\\n\\n            // x is bit shifted to the right each loop, hence this loop will always terminate in a maximum of log_2(count) iterations\\n            for (x = uint256(count); x > 0; x = x >> 1) {\\n                if ((x & 1) == 1) {\\n                    // first hash is special case\\n                    // inbox stores the root of complete subtrees\\n                    // eg if count = 4 = 0b100, then the first complete subtree is inbox[2]\\n                    // inbox = [H(3), H(1,2), H(1,4)], we read inbox[2] directly\\n\\n                    stateRoot = inbox[height];\\n                    break;\\n                }\\n                height++;\\n            }\\n\\n            // after the first hash, we can calculate the root incrementally\\n            for (x = x >> 1; x > 0; x = x >> 1) {\\n                height++;\\n                if ((x & 1) == 1) {\\n                    // sort sibling hashes as a convention for efficient proof validation\\n                    stateRoot = sortConcatAndHash(inbox[height], stateRoot);\\n                }\\n            }\\n        }\\n\\n        snapshots[epoch] = stateRoot;\\n\\n        emit SnapshotSaved(count);\\n    }\\n\\n    /**\\n     * @dev Helper function to calculate merkle tree interior nodes by sorting and concatenating and hashing a pair of children nodes, left and right.\\n     * note: EVM scratch space is used to efficiently calculate hashes.\\n     * @param left The left hash.\\n     * @param right The right hash.\\n     * @return parent The parent hash.\\n     */\\n    function sortConcatAndHash(bytes32 left, bytes32 right) internal pure returns (bytes32 parent) {\\n        // sort sibling hashes as a convention for efficient proof validation\\n        if (left < right) {\\n            // efficient hash using EVM scratch space\\n            assembly {\\n                mstore(0x00, left)\\n                mstore(0x20, right)\\n                parent := keccak256(0x00, 0x40)\\n            }\\n        } else {\\n            assembly {\\n                mstore(0x00, right)\\n                mstore(0x20, left)\\n                parent := keccak256(0x00, 0x40)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Sends the state root snapshot using Arbitrum's canonical bridge.\\n     * @param epoch The epoch of the snapshot requested to send.\\n     * @param claim The claim associated with the epoch\\n     */\\n    function sendSnapshot(uint256 epoch, Claim memory claim) external virtual {\\n        unchecked {\\n            require(epoch < block.timestamp / epochPeriod, \\\"Can only send past epoch snapshot.\\\");\\n        }\\n\\n        bytes memory data = abi.encodeCall(IRouterToL1.route, (epoch, snapshots[epoch], claim));\\n\\n        // Arbitrum -> Ethereum message with native bridge\\n        // docs: https://developer.arbitrum.io/for-devs/cross-chain-messsaging#arbitrum-to-ethereum-messaging\\n        // example: https://github.com/OffchainLabs/arbitrum-tutorials/blob/2c1b7d2db8f36efa496e35b561864c0f94123a5f/packages/greeter/contracts/arbitrum/GreeterL2.sol#L25\\n        bytes32 ticketID = bytes32(ARB_SYS.sendTxToL1(routerArbToGnosis, data));\\n\\n        emit SnapshotSent(epoch, ticketID);\\n    }\\n}\\n\",\"keccak256\":\"0xf06a72368ab205fc80fc99ae00c36b073f1d82b5488509c8b83245f03cc010f1\",\"license\":\"MIT\"},\"src/canonical/arbitrum/IArbSys.sol\":{\"content\":\"// https://developer.arbitrum.io/arbos/precompiles#arbsys\\n// https://github.com/OffchainLabs/nitro-contracts/blob/39ea5a163afc637e2706d9be29cf7a289c300d00/src/precompiles/ArbSys.sol\\n// https://arbiscan.io/address/0x0000000000000000000000000000000000000064#code\\n// interface is pruned for relevant function stubs\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title System level functionality\\n * @notice For use by contracts to interact with core L2-specific functionality.\\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\\n */\\ninterface IArbSys {\\n    /**\\n     * @notice Send a transaction to L1\\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\\n     * to a contract address without any code (as enforced by the Bridge contract).\\n     * @param destination recipient address on L1\\n     * @param data (optional) calldata for L1 contract call\\n     * @return a unique identifier for this L2-to-L1 transaction.\\n     */\\n    function sendTxToL1(address destination, bytes calldata data) external payable returns (uint256);\\n}\\n\",\"keccak256\":\"0x0029d413171b339edaae794d96d33fa7f8a1500b6ea27e2a533ae7333337c50b\"},\"src/interfaces/inboxes/IVeaInbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@jaybuidl, @shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\ninterface IVeaInbox {\\n    /**\\n     * @dev Sends an arbitrary message to receiving chain.\\n     * Note: Calls authenticated by receiving gateway checking the sender argument.\\n     * @param to The cross-domain contract address which receives the calldata.\\n     * @param fnSelection The function selector of the receiving contract.\\n     * @param data The message calldata, abi.encode(...)\\n     * @return msgId The index of the message in the inbox, as a message Id, needed to relay the message.\\n     */\\n    function sendMessage(address to, bytes4 fnSelection, bytes memory data) external returns (uint64 msgId);\\n\\n    /**\\n     * Saves snapshot of state root.\\n     * `O(log(count))` where count number of messages in the inbox.\\n     * @dev Snapshots can be saved a maximum of once per epoch.\\n     */\\n    function saveSnapshot() external;\\n}\\n\",\"keccak256\":\"0xb15fccb6e81e813ff5051d49919a3286cb07cb71359e672001e05cfc45d7a614\",\"license\":\"MIT\"},\"src/interfaces/routers/IRouterToL1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../types/VeaClaim.sol\\\";\\n\\n/**\\n * @dev Interface of the Vea Router on an intermediary chain which routes messages to an L1 chain like Gnosis, Polygon POS etc. as a final destination.\\n * @dev eg. L2 on Gnosis -> Gnosis (L1) -> Ethereum (L1), the IRouterToL1 will be deployed on Gnosis (L1) routing messages to Ethereum (L1).\\n * @dev eg. L2 on Ethereum -> Ethereum (L1) -> Gnosis (L1), the IRouterToL1 will be deployed on Ethereum (L1) routing messages to Gnosis (L1). \\n */\\ninterface IRouterToL1 {\\n    /**\\n     * Note: Access restricted to canonical sending-chain bridge.\\n     * @dev Routes state root snapshots through intermediary chains to the final destination L1 chain.\\n     * @param epoch The epoch to verify.\\n     * @param stateRoot The true state root for the epoch.\\n     * @param claim The claim associated with the epoch.\\n     */\\n    function route(uint256 epoch, bytes32 stateRoot, Claim memory claim) external;\\n}\\n\",\"keccak256\":\"0x492f073ac9e0f6fae6b368aa22d46219519f82a0dfd760c7fccaeaa78b4ac465\",\"license\":\"MIT\"},\"src/interfaces/types/VeaClaim.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@jaybuidl, @shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\nenum Party {\\n    None,\\n    Claimer,\\n    Challenger\\n}\\n\\nstruct Claim {\\n    bytes32 stateRoot;\\n    address claimer;\\n    uint32 timestamp;\\n    uint32 blocknumber;\\n    Party honest;\\n    address challenger;\\n}\\n\",\"keccak256\":\"0x1bdda50afbf5f966278a867e7149397ed820de658c15dda4266e70c314df17d2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b50604051610bd4380380610bd483398101604081905261002f916100a5565b60808290526001600160a01b03811660a0528161009e5760405162461bcd60e51b8152602060048201526024808201527f45706f636820706572696f64206d7573742062652067726561746572207468616044820152633710181760e11b606482015260840160405180910390fd5b50506100e2565b600080604083850312156100b857600080fd5b825160208401519092506001600160a01b03811681146100d757600080fd5b809150509250929050565b60805160a051610ab961011b60003960008181610116015261058001526000818160e10152818161019b015261048d0152610ab96000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063d5e6a9df1161005b578063d5e6a9df14610111578063d6565a2d14610150578063e149b5ec14610170578063e5a1c3561461018357600080fd5b806306661abd1461008d57806351920535146100bf5780635f85896c146100c9578063b5b7a184146100dc575b600080fd5b6041546100a19067ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b6100c7610196565b005b6100a16100d7366004610702565b61031f565b6101037f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100b6565b6101387f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100b6565b61010361015e3660046107c7565b60006020819052908152604090205481565b6100c761017e3660046107f4565b61048b565b6101036101913660046107c7565b61062b565b6000807f000000000000000000000000000000000000000000000000000000000000000042816101c8576101c8610894565b046000818152602081905260409020549092501561023c5760405162461bcd60e51b815260206004820152602660248201527f536e617073686f7420616c72656164792074616b656e20666f7220746869732060448201526532b837b1b41760d11b60648201526084015b60405180910390fd5b60415460009067ffffffffffffffff165b8015610286578060011660010361027a5760018260408110610271576102716108aa565b01549250610286565b6001918201911c61024d565b60011c5b80156102c85760019182019181811690036102c0576102bd600183604081106102b5576102b56108aa565b015484610642565b92505b60011c61028a565b505060008281526020818152604091829020839055604154915167ffffffffffffffff90921682527f8d762ebc760982a11d9a00cc7c1c4c91f9c1084b85633ee8ca462da42465f1d9910160405180910390a15050565b60415460009067ffffffffffffffff9081169081106103715760405162461bcd60e51b815260206004820152600e60248201526d24b73137bc1034b990333ab6361760911b6044820152606401610233565b6040516000908290879061038d908890339089906020016108e4565b60408051601f19818403018152908290526103ac93929160200161091a565b60408051601f1981840301815291905280516020808301919091206000908152908120919250600184015b60018116600003610410576103f8600183604081106102b5576102b56108aa565b92506001918201911c677fffffffffffffff166103d7565b508160018260408110610425576104256108aa565b0155506041805467ffffffffffffffff19166001850167ffffffffffffffff161790556040517f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03690610478908490610995565b60405180910390a1509095945050505050565b7f000000000000000000000000000000000000000000000000000000000000000042816104ba576104ba610894565b0482106105145760405162461bcd60e51b815260206004820152602260248201527f43616e206f6e6c792073656e6420706173742065706f636820736e617073686f6044820152613a1760f11b6064820152608401610233565b60008281526020819052604080822054905161053691859185906024016109af565b60408051601f198184030181529181526020820180516001600160e01b031663b9457b0760e01b179052516349460b4d60e11b815290915060009060649063928c169a906105aa907f0000000000000000000000000000000000000000000000000000000000000000908690600401610a3e565b6020604051808303816000875af11580156105c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ed9190610a6a565b60405181815290915084907f6fdd49f435101fc7b6ebdec7c8972932a926d18f6cb78a8891dfe950743b6b829060200160405180910390a250505050565b6001816040811061063b57600080fd5b0154905081565b60008183101561066057826000528160205260406000209050610670565b8160005282602052604060002090505b92915050565b80356001600160a01b038116811461068d57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405160c0810167ffffffffffffffff811182821017156106cb576106cb610692565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156106fa576106fa610692565b604052919050565b60008060006060848603121561071757600080fd5b61072084610676565b92506020848101356001600160e01b03198116811461073e57600080fd5b9250604085013567ffffffffffffffff8082111561075b57600080fd5b818701915087601f83011261076f57600080fd5b81358181111561078157610781610692565b610793601f8201601f191685016106d1565b915080825288848285010111156107a957600080fd5b80848401858401376000848284010152508093505050509250925092565b6000602082840312156107d957600080fd5b5035919050565b803563ffffffff8116811461068d57600080fd5b60008082840360e081121561080857600080fd5b8335925060c0601f198201121561081e57600080fd5b506108276106a8565b6020840135815261083a60408501610676565b602082015261084b606085016107e0565b604082015261085c608085016107e0565b606082015260a08401356003811061087357600080fd5b608082015261088460c08501610676565b60a0820152809150509250929050565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60005b838110156108db5781810151838201526020016108c3565b50506000910152565b63ffffffff60e01b841681528260048201526000825161090b8160248501602087016108c0565b91909101602401949350505050565b67ffffffffffffffff60c01b8460c01b1681526bffffffffffffffffffffffff198360601b1660088201526000825161095a81601c8501602087016108c0565b91909101601c01949350505050565b600081518084526109818160208601602086016108c0565b601f01601f19169290920160200192915050565b6020815260006109a86020830184610969565b9392505050565b6000610100820190508482528360208301528251604083015260018060a01b036020840151166060830152604083015163ffffffff80821660808501528060608601511660a08501525050608083015160038110610a1d57634e487b7160e01b600052602160045260246000fd5b60c083015260a092909201516001600160a01b031660e09091015292915050565b6001600160a01b0383168152604060208201819052600090610a6290830184610969565b949350505050565b600060208284031215610a7c57600080fd5b505191905056fea26469706673582212200e7bd77319f57f52c06efc0038c9ad9447c382439831442f8d1006fe38c9e9ce64736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063d5e6a9df1161005b578063d5e6a9df14610111578063d6565a2d14610150578063e149b5ec14610170578063e5a1c3561461018357600080fd5b806306661abd1461008d57806351920535146100bf5780635f85896c146100c9578063b5b7a184146100dc575b600080fd5b6041546100a19067ffffffffffffffff1681565b60405167ffffffffffffffff90911681526020015b60405180910390f35b6100c7610196565b005b6100a16100d7366004610702565b61031f565b6101037f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100b6565b6101387f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100b6565b61010361015e3660046107c7565b60006020819052908152604090205481565b6100c761017e3660046107f4565b61048b565b6101036101913660046107c7565b61062b565b6000807f000000000000000000000000000000000000000000000000000000000000000042816101c8576101c8610894565b046000818152602081905260409020549092501561023c5760405162461bcd60e51b815260206004820152602660248201527f536e617073686f7420616c72656164792074616b656e20666f7220746869732060448201526532b837b1b41760d11b60648201526084015b60405180910390fd5b60415460009067ffffffffffffffff165b8015610286578060011660010361027a5760018260408110610271576102716108aa565b01549250610286565b6001918201911c61024d565b60011c5b80156102c85760019182019181811690036102c0576102bd600183604081106102b5576102b56108aa565b015484610642565b92505b60011c61028a565b505060008281526020818152604091829020839055604154915167ffffffffffffffff90921682527f8d762ebc760982a11d9a00cc7c1c4c91f9c1084b85633ee8ca462da42465f1d9910160405180910390a15050565b60415460009067ffffffffffffffff9081169081106103715760405162461bcd60e51b815260206004820152600e60248201526d24b73137bc1034b990333ab6361760911b6044820152606401610233565b6040516000908290879061038d908890339089906020016108e4565b60408051601f19818403018152908290526103ac93929160200161091a565b60408051601f1981840301815291905280516020808301919091206000908152908120919250600184015b60018116600003610410576103f8600183604081106102b5576102b56108aa565b92506001918201911c677fffffffffffffff166103d7565b508160018260408110610425576104256108aa565b0155506041805467ffffffffffffffff19166001850167ffffffffffffffff161790556040517f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03690610478908490610995565b60405180910390a1509095945050505050565b7f000000000000000000000000000000000000000000000000000000000000000042816104ba576104ba610894565b0482106105145760405162461bcd60e51b815260206004820152602260248201527f43616e206f6e6c792073656e6420706173742065706f636820736e617073686f6044820152613a1760f11b6064820152608401610233565b60008281526020819052604080822054905161053691859185906024016109af565b60408051601f198184030181529181526020820180516001600160e01b031663b9457b0760e01b179052516349460b4d60e11b815290915060009060649063928c169a906105aa907f0000000000000000000000000000000000000000000000000000000000000000908690600401610a3e565b6020604051808303816000875af11580156105c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ed9190610a6a565b60405181815290915084907f6fdd49f435101fc7b6ebdec7c8972932a926d18f6cb78a8891dfe950743b6b829060200160405180910390a250505050565b6001816040811061063b57600080fd5b0154905081565b60008183101561066057826000528160205260406000209050610670565b8160005282602052604060002090505b92915050565b80356001600160a01b038116811461068d57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405160c0810167ffffffffffffffff811182821017156106cb576106cb610692565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156106fa576106fa610692565b604052919050565b60008060006060848603121561071757600080fd5b61072084610676565b92506020848101356001600160e01b03198116811461073e57600080fd5b9250604085013567ffffffffffffffff8082111561075b57600080fd5b818701915087601f83011261076f57600080fd5b81358181111561078157610781610692565b610793601f8201601f191685016106d1565b915080825288848285010111156107a957600080fd5b80848401858401376000848284010152508093505050509250925092565b6000602082840312156107d957600080fd5b5035919050565b803563ffffffff8116811461068d57600080fd5b60008082840360e081121561080857600080fd5b8335925060c0601f198201121561081e57600080fd5b506108276106a8565b6020840135815261083a60408501610676565b602082015261084b606085016107e0565b604082015261085c608085016107e0565b606082015260a08401356003811061087357600080fd5b608082015261088460c08501610676565b60a0820152809150509250929050565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60005b838110156108db5781810151838201526020016108c3565b50506000910152565b63ffffffff60e01b841681528260048201526000825161090b8160248501602087016108c0565b91909101602401949350505050565b67ffffffffffffffff60c01b8460c01b1681526bffffffffffffffffffffffff198360601b1660088201526000825161095a81601c8501602087016108c0565b91909101601c01949350505050565b600081518084526109818160208601602086016108c0565b601f01601f19169290920160200192915050565b6020815260006109a86020830184610969565b9392505050565b6000610100820190508482528360208301528251604083015260018060a01b036020840151166060830152604083015163ffffffff80821660808501528060608601511660a08501525050608083015160038110610a1d57634e487b7160e01b600052602160045260246000fd5b60c083015260a092909201516001600160a01b031660e09091015292915050565b6001600160a01b0383168152604060208201819052600090610a6290830184610969565b949350505050565b600060208284031215610a7c57600080fd5b505191905056fea26469706673582212200e7bd77319f57f52c06efc0038c9ad9447c382439831442f8d1006fe38c9e9ce64736f6c63430008120033",
  "devdoc": {
    "events": {
      "MessageSent(bytes)": {
        "details": "Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.",
        "params": {
          "nodeData": "The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, message), outbox relays to.call(message)"
        }
      },
      "SnapshotSaved(uint64)": {
        "params": {
          "count": "The count of messages in the merkle tree."
        }
      },
      "SnapshotSent(uint256,bytes32)": {
        "details": "The event is emitted when a snapshot is sent through the canonical arbitrum bridge.",
        "params": {
          "epochSent": "The epoch of the snapshot.",
          "ticketId": "The ticketId of the L2->L1 message."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor. Note: epochPeriod must match the VeaOutboxArbToGnosis contract deployment on Gnosis, since it's on a different chain, we can't read it and trust the deployer to set a correct value",
        "params": {
          "_epochPeriod": "The duration in seconds between epochs.",
          "_routerArbToGnosis": "The router on Ethereum that routes from Arbitrum to Gnosis."
        }
      },
      "saveSnapshot()": {
        "details": "Saves snapshot of state root. Snapshots can be saved a maximum of once per epoch. `O(log(count))` where count number of messages in the inbox. Note: See merkle tree docs for details how inbox manages state."
      },
      "sendMessage(address,bytes4,bytes)": {
        "details": "Sends an arbitrary message to Gnosis. `O(log(count))` where count is the number of messages already sent. Amortized cost is constant. Note: See merkle tree documentation for details how inbox manages state.",
        "params": {
          "data": "The message calldata, abi.encode(param1, param2, ...)",
          "fnSelector": "The function selector of the receiving contract.",
          "to": "The address of the contract on the receiving chain which receives the calldata."
        },
        "returns": {
          "_0": "msgId The zero based index of the message in the inbox."
        }
      },
      "sendSnapshot(uint256,(bytes32,address,uint32,uint32,uint8,address))": {
        "details": "Sends the state root snapshot using Arbitrum's canonical bridge.",
        "params": {
          "claim": "The claim associated with the epoch",
          "epoch": "The epoch of the snapshot requested to send."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "SnapshotSaved(uint64)": {
        "notice": "The bridgers can watch this event to claim the stateRoot on the veaOutbox."
      }
    },
    "kind": "user",
    "methods": {},
    "notice": "Vea Inbox From Arbitrum to Gnosis. Note: This contract is deployed on the Arbitrum.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1627,
        "contract": "src/arbitrumToGnosis/VeaInboxArbToGnosis.sol:VeaInboxArbToGnosis",
        "label": "snapshots",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_bytes32)"
      },
      {
        "astId": 1631,
        "contract": "src/arbitrumToGnosis/VeaInboxArbToGnosis.sol:VeaInboxArbToGnosis",
        "label": "inbox",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_bytes32)64_storage"
      },
      {
        "astId": 1633,
        "contract": "src/arbitrumToGnosis/VeaInboxArbToGnosis.sol:VeaInboxArbToGnosis",
        "label": "count",
        "offset": 0,
        "slot": "65",
        "type": "t_uint64"
      }
    ],
    "types": {
      "t_array(t_bytes32)64_storage": {
        "base": "t_bytes32",
        "encoding": "inplace",
        "label": "bytes32[64]",
        "numberOfBytes": "2048"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}
