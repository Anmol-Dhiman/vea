{
  "address": "0x3b894FE680deB990b4Fb7E7D0000C32Af06687C3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_epochPeriod",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_veaOutbox",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "nodeData",
          "type": "bytes"
        }
      ],
      "name": "MessageSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "name": "SnapshotSaved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "epochSent",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "ticketId",
          "type": "bytes32"
        }
      ],
      "name": "SnapshotSent",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ARB_SYS",
      "outputs": [
        {
          "internalType": "contract IArbSys",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "epochPeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "inbox",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "saveSnapshot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "fnSelector",
          "type": "bytes4"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "sendMessage",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "epochSend",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "stateRoot",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "claimer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "timestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "blocknumber",
              "type": "uint32"
            },
            {
              "internalType": "enum IVeaOutboxArbGoerliToGoerli.Party",
              "name": "honest",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "challenger",
              "type": "address"
            }
          ],
          "internalType": "struct IVeaOutboxArbGoerliToGoerli.Claim",
          "name": "claim",
          "type": "tuple"
        }
      ],
      "name": "sendSnapshot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "snapshots",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "veaOutbox",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xffbab1ab0ef14e3d4325f92bb7052b9edc897aaaf09b30bef46b0fd2dafd0ade",
  "receipt": {
    "to": null,
    "from": "0x209469C921db9d5Bd77084370e80B63d5cdD63C1",
    "contractAddress": "0x3b894FE680deB990b4Fb7E7D0000C32Af06687C3",
    "transactionIndex": 1,
    "gasUsed": "656232",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0c720420784ee3485fe3b4d9b433a178289b7b2539a63557ec375837619a3ac1",
    "transactionHash": "0xffbab1ab0ef14e3d4325f92bb7052b9edc897aaaf09b30bef46b0fd2dafd0ade",
    "logs": [],
    "blockNumber": 18151531,
    "cumulativeGasUsed": "656232",
    "status": 1,
    "byzantium": true
  },
  "args": [
    3600,
    "0xAA0FA4fB781d8e17F3998291774601e06f2f27be"
  ],
  "numDeployments": 1,
  "solcInputHash": "c1bd9c1deff19ffeff78fee5cb8f2036",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochPeriod\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_veaOutbox\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"nodeData\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"SnapshotSaved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epochSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ticketId\",\"type\":\"bytes32\"}],\"name\":\"SnapshotSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ARB_SYS\",\"outputs\":[{\"internalType\":\"contract IArbSys\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saveSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fnSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochSend\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blocknumber\",\"type\":\"uint32\"},{\"internalType\":\"enum IVeaOutboxArbGoerliToGoerli.Party\",\"name\":\"honest\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"internalType\":\"struct IVeaOutboxArbGoerliToGoerli.Claim\",\"name\":\"claim\",\"type\":\"tuple\"}],\"name\":\"sendSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veaOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"MessageSent(bytes)\":{\"details\":\"Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.\",\"params\":{\"nodeData\":\"The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, data), outbox relays to.call(data)\"}},\"SnapshotSaved(uint256)\":{\"params\":{\"count\":\"The count of messages in the merkle tree\"}},\"SnapshotSent(uint256,bytes32)\":{\"details\":\"The event is emitted when a snapshot through the canonical arbiturm bridge.\",\"params\":{\"epochSent\":\"The epoch of the snapshot.\",\"ticketId\":\"The ticketId of the L2->L1 message.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Constructor.\",\"params\":{\"_epochPeriod\":\"The duration in seconds between epochs.\",\"_veaOutbox\":\"The veaOutbox on ethereum.\"}},\"saveSnapshot()\":{\"details\":\"Snapshots can be saved a maximum of once per epoch.\"},\"sendMessage(address,bytes4,bytes)\":{\"details\":\"Sends an arbitrary message to a receiving chain. `O(log(count))` where count is the number of messages already sent. Note: Amortized cost is O(1).\",\"params\":{\"data\":\"The message calldata, abi.encode(param1, param2, ...)\",\"fnSelector\":\"The function selector of the receiving contract.\",\"to\":\"The address of the contract on the receiving chain which receives the calldata.\"},\"returns\":{\"_0\":\"msgId The zero based index of the message in the inbox.\"}},\"sendSnapshot(uint256,(bytes32,address,uint32,uint32,uint8,address))\":{\"details\":\"Sends the state root snapshot using Arbitrum's canonical bridge.\",\"params\":{\"epochSend\":\"The epoch of the snapshot requested to send.\"}}},\"version\":1},\"userdoc\":{\"events\":{\"SnapshotSaved(uint256)\":{\"notice\":\"The bridgers can watch this event to claim the stateRoot on the veaOutbox.\"}},\"kind\":\"user\",\"methods\":{\"saveSnapshot()\":{\"notice\":\"Saves snapshot of state root. `O(log(count))` where count number of messages in the inbox.\"}},\"notice\":\"Vea Bridge Inbox From Arbitrum to Ethereum.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/testnets/arbitrumGoerliToGoerli/VeaInboxArbGoerliToGoerli.sol\":\"VeaInboxArbGoerliToGoerli\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"src/canonical/arbitrum/IArbSys.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity >=0.7.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface IArbSys {\\n    /**\\n     * @notice Get internal version number identifying an ArbOS build\\n     * @return version number as int\\n     */\\n    function arbOSVersion() external pure returns (uint256);\\n\\n    /**\\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n     * @return block number as int\\n     */\\n    function arbBlockNumber() external view returns (uint256);\\n\\n    /**\\n     * @notice Send given amount of Eth to dest from sender.\\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n     * @param destination recipient address on L1\\n     * @return unique identifier for this L2-to-L1 transaction.\\n     */\\n    function withdrawEth(address destination) external payable returns (uint256);\\n\\n    /**\\n     * @notice Send a transaction to L1\\n     * @param destination recipient address on L1\\n     * @param calldataForL1 (optional) calldata for L1 contract call\\n     * @return a unique identifier for this L2-to-L1 transaction.\\n     */\\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\\n\\n    /**\\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n     * @param account target account\\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n     */\\n    function getTransactionCount(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice get the value of target L2 storage slot\\n     * This function is only callable from address 0 to prevent contracts from being able to call it\\n     * @param account target account\\n     * @param index target index of storage slot\\n     * @return stotage value for the given account at the given index\\n     */\\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @notice check if current call is coming from l1\\n     * @return true if the caller of this was called directly from L1\\n     */\\n    function isTopLevelCall() external view returns (bool);\\n\\n    event EthWithdrawal(address indexed destAddr, uint256 amount);\\n\\n    event L2ToL1Transaction(\\n        address caller,\\n        address indexed destination,\\n        uint256 indexed uniqueId,\\n        uint256 indexed batchNumber,\\n        uint256 indexInBatch,\\n        uint256 arbBlockNum,\\n        uint256 ethBlockNum,\\n        uint256 timestamp,\\n        uint256 callvalue,\\n        bytes data\\n    );\\n}\\n\",\"keccak256\":\"0x2abbc6cf12d56c18cf4339b34747f6adea78f17a82e1813923a05d9aa7597ef3\",\"license\":\"Apache-2.0\"},\"src/interfaces/IVeaInbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@jaybuidl, @shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\ninterface IVeaInbox {\\n    /**\\n     * Note: Calls authenticated by receiving gateway checking the sender argument.\\n     * @dev Sends an arbitrary message to Ethereum.\\n     * @param to The cross-domain contract address which receives the calldata.\\n     * @param fnSelection The function selector of the receiving contract.\\n     * @param data The message calldata, abi.encode(...)\\n     * @return msgId The index of the message in the inbox, as a message Id, needed to relay the message.\\n     */\\n    function sendMessage(address to, bytes4 fnSelection, bytes memory data) external returns (uint64 msgId);\\n\\n    /**\\n     * Saves snapshot of state root.\\n     * `O(log(count))` where count number of messages in the inbox.\\n     * @dev Snapshots can be saved a maximum of once per epoch.\\n     */\\n    function saveSnapshot() external;\\n}\",\"keccak256\":\"0x586992f591f8907fe7cd4e953debeb7516c57e0d67473cebde621db8800e90e0\",\"license\":\"MIT\"},\"src/testnets/arbitrumGoerliToGoerli/VeaInboxArbGoerliToGoerli.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@jaybuidl, @shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../../canonical/arbitrum/IArbSys.sol\\\";\\nimport \\\"../../interfaces/IVeaInbox.sol\\\";\\nimport \\\"./interfaces/IVeaOutboxArbGoerliToGoerli.sol\\\";\\n\\n/**\\n * Vea Bridge Inbox From Arbitrum to Ethereum.\\n */\\ncontract VeaInboxArbGoerliToGoerli is IVeaInbox {\\n    /**\\n     * @dev Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.\\n     * @param nodeData The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, data), outbox relays to.call(data)\\n     */\\n    event MessageSent(bytes nodeData);\\n\\n    /**\\n     * The bridgers can watch this event to claim the stateRoot on the veaOutbox.\\n     * @param count The count of messages in the merkle tree\\n     */\\n    event SnapshotSaved(uint256 count);\\n\\n    /**\\n     * @dev The event is emitted when a snapshot through the canonical arbiturm bridge.\\n     * @param epochSent The epoch of the snapshot.\\n     * @param ticketId The ticketId of the L2->L1 message.\\n     */\\n    event SnapshotSent(uint256 indexed epochSent, bytes32 ticketId);\\n\\n    IArbSys public constant ARB_SYS = IArbSys(address(100));\\n\\n    uint256 public immutable epochPeriod; // Epochs mark the period between stateroot snapshots\\n    address public immutable veaOutbox; // The vea outbox on ethereum.\\n\\n    mapping(uint256 => bytes32) public snapshots; // epoch => state root snapshot\\n\\n    // inbox represents minimum data availability to maintain incremental merkle tree.\\n    // supports a max of 2^64 - 1 messages and will *never* overflow, see parameter docs.\\n\\n    bytes32[64] public inbox; // stores minimal set of complete subtree roots of the merkle tree to increment.\\n    uint256 public count; // count of messages in the merkle tree\\n\\n    /**\\n     * @dev Constructor.\\n     * @param _epochPeriod The duration in seconds between epochs.\\n     * @param _veaOutbox The veaOutbox on ethereum.\\n     */\\n    constructor(uint256 _epochPeriod, address _veaOutbox) {\\n        epochPeriod = _epochPeriod;\\n        veaOutbox = _veaOutbox;\\n    }\\n\\n    /**\\n     * @dev Sends an arbitrary message to a receiving chain.\\n     * `O(log(count))` where count is the number of messages already sent.\\n     * Note: Amortized cost is O(1).\\n     * @param to The address of the contract on the receiving chain which receives the calldata.\\n     * @param fnSelector The function selector of the receiving contract.\\n     * @param data The message calldata, abi.encode(param1, param2, ...)\\n     * @return msgId The zero based index of the message in the inbox.\\n     */\\n    function sendMessage(address to, bytes4 fnSelector, bytes memory data) external override returns (uint64) {\\n        uint256 oldCount = count;\\n\\n        bytes memory nodeData = abi.encodePacked(\\n            uint64(oldCount),\\n            to,\\n            // data for outbox relay\\n            abi.encodePacked( // abi.encodeWithSelector(fnSelector, msg.sender, data)\\n                fnSelector,\\n                bytes32(uint256(uint160(msg.sender))), // big endian padded encoding of msg.sender, simulating abi.encodeWithSelector\\n                data\\n            )\\n        );\\n\\n        // single hashed leaf\\n        bytes32 newInboxNode = keccak256(nodeData);\\n\\n        // double hashed leaf\\n        // avoids second order preimage attacks\\n        // https://flawed.net.nz/2018/02/21/attacking-merkle-trees-with-a-second-preimage-attack/\\n        assembly {\\n            // efficient hash using EVM scratch space\\n            mstore(0x00, newInboxNode)\\n            newInboxNode := keccak256(0x00, 0x20)\\n        }\\n\\n        // increment merkle tree calculating minimal number of hashes\\n        unchecked {\\n            uint256 height;\\n\\n            // x = oldCount + 1; acts as a bit mask to determine if a hash is needed\\n            // note: x is always non-zero, and x is bit shifted to the right each loop\\n            // hence this loop will always terminate in a maximum of log_2(oldCount + 1) iterations\\n            for (uint256 x = oldCount + 1; x & 1 == 0; x = x >> 1) {\\n                bytes32 oldInboxNode = inbox[height];\\n                // sort sibling hashes as a convention for efficient proof validation\\n                newInboxNode = sortConcatAndHash(oldInboxNode, newInboxNode);\\n                height++;\\n            }\\n\\n            inbox[height] = newInboxNode;\\n\\n            // finally increment count\\n            count = oldCount + 1;\\n        }\\n\\n        emit MessageSent(nodeData);\\n\\n        // old count is the zero indexed leaf position in the tree, acts as a msgId\\n        // gateways should index these msgIds to later relay proofs\\n        return uint64(oldCount);\\n    }\\n\\n    /**\\n     * Saves snapshot of state root.\\n     * `O(log(count))` where count number of messages in the inbox.\\n     * @dev Snapshots can be saved a maximum of once per epoch.\\n     */\\n    function saveSnapshot() external {\\n        uint256 epoch;\\n        bytes32 stateRoot;\\n\\n        unchecked {\\n            epoch = block.timestamp / epochPeriod;\\n\\n            require(snapshots[epoch] == bytes32(0), \\\"Snapshot already taken for this epoch.\\\");\\n\\n            // calculate the current root of the incremental merkle tree encoded in the inbox\\n\\n            uint256 height;\\n\\n            // x acts as a bit mask to determine if the hash stored in the inbox contributes to the root\\n            uint256 x;\\n\\n            // x is bit shifted to the right each loop, hence this loop will always terminate in a maximum of log_2(count) iterations\\n            for (x = count; x > 0; x = x >> 1) {\\n                if ((x & 1) == 1) {\\n                    // first hash is special case\\n                    // inbox stores the root of complete subtrees\\n                    // eg if count = 4 = 0b100, then the first complete subtree is inbox[2]\\n                    // inbox = [H(m_3), H(H(m_1),H(m_2)) H(H(H(m_1),H(m_2)),H(H(m_3),H(m_4)))], we read inbox[2] directly\\n\\n                    stateRoot = inbox[height];\\n                    break;\\n                }\\n                height++;\\n            }\\n\\n            for (x = x >> 1; x > 0; x = x >> 1) {\\n                height++;\\n                if ((x & 1) == 1) {\\n                    bytes32 inboxHash = inbox[height];\\n                    // sort sibling hashes as a convention for efficient proof validation\\n                    stateRoot = sortConcatAndHash(inboxHash, stateRoot);\\n                }\\n            }\\n        }\\n\\n        snapshots[epoch] = stateRoot;\\n\\n        emit SnapshotSaved(count);\\n    }\\n\\n    /**\\n     * @dev Helper function to calculate merkle tree interior nodes by sorting and concatenating and hashing sibling hashes.\\n     * note: EVM scratch space is used to efficiently calculate hashes.\\n     * @param child_1 The first sibling hash.\\n     * @param child_2 The second sibling hash.\\n     * @return parent The parent hash.\\n     */\\n    function sortConcatAndHash(bytes32 child_1, bytes32 child_2) internal pure returns (bytes32 parent) {\\n        // sort sibling hashes as a convention for efficient proof validation\\n        // efficient hash using EVM scratch space\\n        if (child_1 > child_2) {\\n            assembly {\\n                mstore(0x00, child_2)\\n                mstore(0x20, child_1)\\n                parent := keccak256(0x00, 0x40)\\n            }\\n        } else {\\n            assembly {\\n                mstore(0x00, child_1)\\n                mstore(0x20, child_2)\\n                parent := keccak256(0x00, 0x40)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Sends the state root snapshot using Arbitrum's canonical bridge.\\n     * @param epochSend The epoch of the snapshot requested to send.\\n     */\\n    function sendSnapshot(uint256 epochSend, IVeaOutboxArbGoerliToGoerli.Claim memory claim) external virtual {\\n        unchecked {\\n            require(epochSend < block.timestamp / epochPeriod, \\\"Can only send past epoch snapshot.\\\");\\n        }\\n\\n        bytes memory data = abi.encodeCall(\\n            IVeaOutboxArbGoerliToGoerli.resolveDisputedClaim,\\n            (\\n                epochSend,\\n                snapshots[epochSend],\\n                claim\\n            )\\n        );\\n\\n        bytes32 ticketID = bytes32(ARB_SYS.sendTxToL1(veaOutbox, data));\\n\\n        emit SnapshotSent(epochSend, ticketID);\\n    }\\n}\\n\",\"keccak256\":\"0xa377f36f7806bae3b9dc5d3234fc429587c2e796f9f06932e4d137c2c43dde32\",\"license\":\"MIT\"},\"src/testnets/arbitrumGoerliToGoerli/interfaces/IVeaOutboxArbGoerliToGoerli.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n *  @authors: [@jaybuidl, @shotaronowhere]\\n *  @reviewers: []\\n *  @auditors: []\\n *  @bounties: []\\n *  @deployments: []\\n */\\n\\npragma solidity 0.8.18;\\n\\ninterface IVeaOutboxArbGoerliToGoerli {\\n    enum Party {\\n        None,\\n        Claimer,\\n        Challenger\\n    }\\n\\n    struct Claim {\\n        bytes32 stateRoot;\\n        address claimer;\\n        uint32 timestamp;\\n        uint32 blocknumber;\\n        Party honest;\\n        address challenger;\\n    }\\n\\n    /**\\n     * Note: Gateways expect first argument of message call to be the inbox sender, used for authenitcation.\\n     * @dev Verifies and relays the message.\\n     * @param proof The merkle proof to prove the message.\\n     * @param msgId The zero based index of the message in the inbox.\\n     * @param to The address to send the message to.\\n     * @param message The message to relay.\\n     */\\n    function sendMessage(bytes32[] calldata proof, uint64 msgId, address to, bytes calldata message) external;\\n\\n    /**\\n     * Note: Access restricted to canonical bridge.\\n     * @dev Resolves any challenge of the optimistic claim for 'epoch' using the canonical bridge.\\n     * @param epoch The epoch to verify.\\n     * @param stateRoot The true state root for the epoch.\\n     */\\n    function resolveDisputedClaim(uint256 epoch, bytes32 stateRoot, Claim memory claim) external;\\n}\\n\",\"keccak256\":\"0xdc0f1576ba1242fba44a5ee27f4b7af351485a26762c9902a7b6b6c74a8c00ca\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b50604051610b0d380380610b0d83398101604081905261002f91610046565b6080919091526001600160a01b031660a052610083565b6000806040838503121561005957600080fd5b825160208401519092506001600160a01b038116811461007857600080fd5b809150509250929050565b60805160a051610a516100bc60003960008181610156015261051801526000818160ef015281816101a301526104250152610a516000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063bd8e62d611610066578063bd8e62d614610111578063d6565a2d14610131578063dea580b914610151578063e149b5ec14610178578063e5a1c3561461018b57600080fd5b806306661abd1461009857806351920535146100b45780635f85896c146100be578063b5b7a184146100ea575b600080fd5b6100a160415481565b6040519081526020015b60405180910390f35b6100bc61019e565b005b6100d16100cc36600461069a565b610318565b60405167ffffffffffffffff90911681526020016100ab565b6100a17f000000000000000000000000000000000000000000000000000000000000000081565b610119606481565b6040516001600160a01b0390911681526020016100ab565b6100a161013f36600461075f565b60006020819052908152604090205481565b6101197f000000000000000000000000000000000000000000000000000000000000000081565b6100bc61018636600461078c565b610423565b6100a161019936600461075f565b6105c3565b6000807f000000000000000000000000000000000000000000000000000000000000000042816101d0576101d061082c565b04600081815260208190526040902054909250156102445760405162461bcd60e51b815260206004820152602660248201527f536e617073686f7420616c72656164792074616b656e20666f7220746869732060448201526532b837b1b41760d11b60648201526084015b60405180910390fd5b6041546000905b80156102845780600116600103610278576001826040811061026f5761026f610842565b01549250610284565b6001918201911c61024b565b60011c5b80156102cc5760019182019181811690036102c4576000600183604081106102b2576102b2610842565b015490506102c081856105da565b9350505b60011c610288565b50506000828152602081815260409182902083905560415491519182527f8f135def7efb043b292bb76e48b3dd0b59bbe7e1e303862404cd8cc1c36ac3bf910160405180910390a15050565b6041546040516000919082908290879061033a9088903390899060200161087c565b60408051601f19818403018152908290526103599392916020016108b2565b60408051601f1981840301815291905280516020808301919091206000908152908120919250600184015b806001166000036103c1576000600183604081106103a4576103a4610842565b015490506103b281856105da565b9350506001918201911c610384565b5081600182604081106103d6576103d6610842565b015550600183016041556040517f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b0369061041090849061092d565b60405180910390a1509095945050505050565b7f000000000000000000000000000000000000000000000000000000000000000042816104525761045261082c565b0482106104ac5760405162461bcd60e51b815260206004820152602260248201527f43616e206f6e6c792073656e6420706173742065706f636820736e617073686f6044820152613a1760f11b606482015260840161023b565b6000828152602081905260408082205490516104ce9185918590602401610947565b60408051601f198184030181529181526020820180516001600160e01b0316631ee9e40360e21b179052516349460b4d60e11b815290915060009060649063928c169a90610542907f00000000000000000000000000000000000000000000000000000000000000009086906004016109d6565b6020604051808303816000875af1158015610561573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105859190610a02565b60405181815290915084907f6fdd49f435101fc7b6ebdec7c8972932a926d18f6cb78a8891dfe950743b6b829060200160405180910390a250505050565b600181604081106105d357600080fd5b0154905081565b6000818311156105f857816000528260205260406000209050610608565b8260005281602052604060002090505b92915050565b80356001600160a01b038116811461062557600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405160c0810167ffffffffffffffff811182821017156106635761066361062a565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156106925761069261062a565b604052919050565b6000806000606084860312156106af57600080fd5b6106b88461060e565b92506020848101356001600160e01b0319811681146106d657600080fd5b9250604085013567ffffffffffffffff808211156106f357600080fd5b818701915087601f83011261070757600080fd5b8135818111156107195761071961062a565b61072b601f8201601f19168501610669565b9150808252888482850101111561074157600080fd5b80848401858401376000848284010152508093505050509250925092565b60006020828403121561077157600080fd5b5035919050565b803563ffffffff8116811461062557600080fd5b60008082840360e08112156107a057600080fd5b8335925060c0601f19820112156107b657600080fd5b506107bf610640565b602084013581526107d26040850161060e565b60208201526107e360608501610778565b60408201526107f460808501610778565b606082015260a08401356003811061080b57600080fd5b608082015261081c60c0850161060e565b60a0820152809150509250929050565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60005b8381101561087357818101518382015260200161085b565b50506000910152565b63ffffffff60e01b84168152826004820152600082516108a3816024850160208701610858565b91909101602401949350505050565b67ffffffffffffffff60c01b8460c01b1681526bffffffffffffffffffffffff198360601b166008820152600082516108f281601c850160208701610858565b91909101601c01949350505050565b60008151808452610919816020860160208601610858565b601f01601f19169290920160200192915050565b6020815260006109406020830184610901565b9392505050565b6000610100820190508482528360208301528251604083015260018060a01b036020840151166060830152604083015163ffffffff80821660808501528060608601511660a085015250506080830151600381106109b557634e487b7160e01b600052602160045260246000fd5b60c083015260a092909201516001600160a01b031660e09091015292915050565b6001600160a01b03831681526040602082018190526000906109fa90830184610901565b949350505050565b600060208284031215610a1457600080fd5b505191905056fea2646970667358221220305dfa33892ab712e397f42a828052339ea687a0da439ae5724198526dc56b1564736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063bd8e62d611610066578063bd8e62d614610111578063d6565a2d14610131578063dea580b914610151578063e149b5ec14610178578063e5a1c3561461018b57600080fd5b806306661abd1461009857806351920535146100b45780635f85896c146100be578063b5b7a184146100ea575b600080fd5b6100a160415481565b6040519081526020015b60405180910390f35b6100bc61019e565b005b6100d16100cc36600461069a565b610318565b60405167ffffffffffffffff90911681526020016100ab565b6100a17f000000000000000000000000000000000000000000000000000000000000000081565b610119606481565b6040516001600160a01b0390911681526020016100ab565b6100a161013f36600461075f565b60006020819052908152604090205481565b6101197f000000000000000000000000000000000000000000000000000000000000000081565b6100bc61018636600461078c565b610423565b6100a161019936600461075f565b6105c3565b6000807f000000000000000000000000000000000000000000000000000000000000000042816101d0576101d061082c565b04600081815260208190526040902054909250156102445760405162461bcd60e51b815260206004820152602660248201527f536e617073686f7420616c72656164792074616b656e20666f7220746869732060448201526532b837b1b41760d11b60648201526084015b60405180910390fd5b6041546000905b80156102845780600116600103610278576001826040811061026f5761026f610842565b01549250610284565b6001918201911c61024b565b60011c5b80156102cc5760019182019181811690036102c4576000600183604081106102b2576102b2610842565b015490506102c081856105da565b9350505b60011c610288565b50506000828152602081815260409182902083905560415491519182527f8f135def7efb043b292bb76e48b3dd0b59bbe7e1e303862404cd8cc1c36ac3bf910160405180910390a15050565b6041546040516000919082908290879061033a9088903390899060200161087c565b60408051601f19818403018152908290526103599392916020016108b2565b60408051601f1981840301815291905280516020808301919091206000908152908120919250600184015b806001166000036103c1576000600183604081106103a4576103a4610842565b015490506103b281856105da565b9350506001918201911c610384565b5081600182604081106103d6576103d6610842565b015550600183016041556040517f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b0369061041090849061092d565b60405180910390a1509095945050505050565b7f000000000000000000000000000000000000000000000000000000000000000042816104525761045261082c565b0482106104ac5760405162461bcd60e51b815260206004820152602260248201527f43616e206f6e6c792073656e6420706173742065706f636820736e617073686f6044820152613a1760f11b606482015260840161023b565b6000828152602081905260408082205490516104ce9185918590602401610947565b60408051601f198184030181529181526020820180516001600160e01b0316631ee9e40360e21b179052516349460b4d60e11b815290915060009060649063928c169a90610542907f00000000000000000000000000000000000000000000000000000000000000009086906004016109d6565b6020604051808303816000875af1158015610561573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105859190610a02565b60405181815290915084907f6fdd49f435101fc7b6ebdec7c8972932a926d18f6cb78a8891dfe950743b6b829060200160405180910390a250505050565b600181604081106105d357600080fd5b0154905081565b6000818311156105f857816000528260205260406000209050610608565b8260005281602052604060002090505b92915050565b80356001600160a01b038116811461062557600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60405160c0810167ffffffffffffffff811182821017156106635761066361062a565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156106925761069261062a565b604052919050565b6000806000606084860312156106af57600080fd5b6106b88461060e565b92506020848101356001600160e01b0319811681146106d657600080fd5b9250604085013567ffffffffffffffff808211156106f357600080fd5b818701915087601f83011261070757600080fd5b8135818111156107195761071961062a565b61072b601f8201601f19168501610669565b9150808252888482850101111561074157600080fd5b80848401858401376000848284010152508093505050509250925092565b60006020828403121561077157600080fd5b5035919050565b803563ffffffff8116811461062557600080fd5b60008082840360e08112156107a057600080fd5b8335925060c0601f19820112156107b657600080fd5b506107bf610640565b602084013581526107d26040850161060e565b60208201526107e360608501610778565b60408201526107f460808501610778565b606082015260a08401356003811061080b57600080fd5b608082015261081c60c0850161060e565b60a0820152809150509250929050565b634e487b7160e01b600052601260045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60005b8381101561087357818101518382015260200161085b565b50506000910152565b63ffffffff60e01b84168152826004820152600082516108a3816024850160208701610858565b91909101602401949350505050565b67ffffffffffffffff60c01b8460c01b1681526bffffffffffffffffffffffff198360601b166008820152600082516108f281601c850160208701610858565b91909101601c01949350505050565b60008151808452610919816020860160208601610858565b601f01601f19169290920160200192915050565b6020815260006109406020830184610901565b9392505050565b6000610100820190508482528360208301528251604083015260018060a01b036020840151166060830152604083015163ffffffff80821660808501528060608601511660a085015250506080830151600381106109b557634e487b7160e01b600052602160045260246000fd5b60c083015260a092909201516001600160a01b031660e09091015292915050565b6001600160a01b03831681526040602082018190526000906109fa90830184610901565b949350505050565b600060208284031215610a1457600080fd5b505191905056fea2646970667358221220305dfa33892ab712e397f42a828052339ea687a0da439ae5724198526dc56b1564736f6c63430008120033",
  "devdoc": {
    "events": {
      "MessageSent(bytes)": {
        "details": "Relayers watch for these events to construct merkle proofs to execute transactions on Ethereum.",
        "params": {
          "nodeData": "The data to create leaves in the merkle tree. abi.encodePacked(msgId, to, data), outbox relays to.call(data)"
        }
      },
      "SnapshotSaved(uint256)": {
        "params": {
          "count": "The count of messages in the merkle tree"
        }
      },
      "SnapshotSent(uint256,bytes32)": {
        "details": "The event is emitted when a snapshot through the canonical arbiturm bridge.",
        "params": {
          "epochSent": "The epoch of the snapshot.",
          "ticketId": "The ticketId of the L2->L1 message."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Constructor.",
        "params": {
          "_epochPeriod": "The duration in seconds between epochs.",
          "_veaOutbox": "The veaOutbox on ethereum."
        }
      },
      "saveSnapshot()": {
        "details": "Snapshots can be saved a maximum of once per epoch."
      },
      "sendMessage(address,bytes4,bytes)": {
        "details": "Sends an arbitrary message to a receiving chain. `O(log(count))` where count is the number of messages already sent. Note: Amortized cost is O(1).",
        "params": {
          "data": "The message calldata, abi.encode(param1, param2, ...)",
          "fnSelector": "The function selector of the receiving contract.",
          "to": "The address of the contract on the receiving chain which receives the calldata."
        },
        "returns": {
          "_0": "msgId The zero based index of the message in the inbox."
        }
      },
      "sendSnapshot(uint256,(bytes32,address,uint32,uint32,uint8,address))": {
        "details": "Sends the state root snapshot using Arbitrum's canonical bridge.",
        "params": {
          "epochSend": "The epoch of the snapshot requested to send."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "SnapshotSaved(uint256)": {
        "notice": "The bridgers can watch this event to claim the stateRoot on the veaOutbox."
      }
    },
    "kind": "user",
    "methods": {
      "saveSnapshot()": {
        "notice": "Saves snapshot of state root. `O(log(count))` where count number of messages in the inbox."
      }
    },
    "notice": "Vea Bridge Inbox From Arbitrum to Ethereum.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9080,
        "contract": "src/testnets/arbitrumGoerliToGoerli/VeaInboxArbGoerliToGoerli.sol:VeaInboxArbGoerliToGoerli",
        "label": "snapshots",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_bytes32)"
      },
      {
        "astId": 9084,
        "contract": "src/testnets/arbitrumGoerliToGoerli/VeaInboxArbGoerliToGoerli.sol:VeaInboxArbGoerliToGoerli",
        "label": "inbox",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_bytes32)64_storage"
      },
      {
        "astId": 9086,
        "contract": "src/testnets/arbitrumGoerliToGoerli/VeaInboxArbGoerliToGoerli.sol:VeaInboxArbGoerliToGoerli",
        "label": "count",
        "offset": 0,
        "slot": "65",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_array(t_bytes32)64_storage": {
        "base": "t_bytes32",
        "encoding": "inplace",
        "label": "bytes32[64]",
        "numberOfBytes": "2048"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
