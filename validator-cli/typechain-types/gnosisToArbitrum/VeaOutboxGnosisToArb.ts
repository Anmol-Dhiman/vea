/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "../common";

export interface VeaOutboxGnosisToArbInterface extends utils.Interface {
  functions: {
    "BURN_ADDRESS()": FunctionFragment;
    "burn()": FunctionFragment;
    "challenge(uint256,bytes32)": FunctionFragment;
    "challengePeriod()": FunctionFragment;
    "challengers(uint256)": FunctionFragment;
    "claim(uint256,bytes32)": FunctionFragment;
    "claims(uint256)": FunctionFragment;
    "deposit()": FunctionFragment;
    "depositPlusReward()": FunctionFragment;
    "epochAt(uint256)": FunctionFragment;
    "epochNow()": FunctionFragment;
    "epochPeriod()": FunctionFragment;
    "isMsgRelayed(uint256)": FunctionFragment;
    "latestVerifiedEpoch()": FunctionFragment;
    "resolveDisputedClaim(uint256,bytes32)": FunctionFragment;
    "routerGnosisToArb()": FunctionFragment;
    "sendMessage(bytes32[],uint64,address,bytes)": FunctionFragment;
    "sequencerDelayLimit()": FunctionFragment;
    "sequencerFutureLimit()": FunctionFragment;
    "stateRoot()": FunctionFragment;
    "timeoutEpochs()": FunctionFragment;
    "timestampDelayUpdated()": FunctionFragment;
    "timestampFutureUpdated()": FunctionFragment;
    "updateSequencerDelayLimit(uint256,uint256)": FunctionFragment;
    "updateSequencerFutureLimit(uint256,uint256)": FunctionFragment;
    "verifySnapshot(uint256)": FunctionFragment;
    "withdrawChallengeDeposit(uint256)": FunctionFragment;
    "withdrawChallengerEscapeHatch(uint256)": FunctionFragment;
    "withdrawClaimDeposit(uint256)": FunctionFragment;
    "withdrawClaimerEscapeHatch(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "BURN_ADDRESS"
      | "burn"
      | "challenge"
      | "challengePeriod"
      | "challengers"
      | "claim"
      | "claims"
      | "deposit"
      | "depositPlusReward"
      | "epochAt"
      | "epochNow"
      | "epochPeriod"
      | "isMsgRelayed"
      | "latestVerifiedEpoch"
      | "resolveDisputedClaim"
      | "routerGnosisToArb"
      | "sendMessage"
      | "sequencerDelayLimit"
      | "sequencerFutureLimit"
      | "stateRoot"
      | "timeoutEpochs"
      | "timestampDelayUpdated"
      | "timestampFutureUpdated"
      | "updateSequencerDelayLimit"
      | "updateSequencerFutureLimit"
      | "verifySnapshot"
      | "withdrawChallengeDeposit"
      | "withdrawChallengerEscapeHatch"
      | "withdrawClaimDeposit"
      | "withdrawClaimerEscapeHatch"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "BURN_ADDRESS", values?: undefined): string;
  encodeFunctionData(functionFragment: "burn", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "challenge",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "challengePeriod", values?: undefined): string;
  encodeFunctionData(functionFragment: "challengers", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: "claim",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "claims", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "deposit", values?: undefined): string;
  encodeFunctionData(functionFragment: "depositPlusReward", values?: undefined): string;
  encodeFunctionData(functionFragment: "epochAt", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "epochNow", values?: undefined): string;
  encodeFunctionData(functionFragment: "epochPeriod", values?: undefined): string;
  encodeFunctionData(functionFragment: "isMsgRelayed", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "latestVerifiedEpoch", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "resolveDisputedClaim",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "routerGnosisToArb", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sendMessage",
    values: [
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "sequencerDelayLimit", values?: undefined): string;
  encodeFunctionData(functionFragment: "sequencerFutureLimit", values?: undefined): string;
  encodeFunctionData(functionFragment: "stateRoot", values?: undefined): string;
  encodeFunctionData(functionFragment: "timeoutEpochs", values?: undefined): string;
  encodeFunctionData(functionFragment: "timestampDelayUpdated", values?: undefined): string;
  encodeFunctionData(functionFragment: "timestampFutureUpdated", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updateSequencerDelayLimit",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateSequencerFutureLimit",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "verifySnapshot", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "withdrawChallengeDeposit", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "withdrawChallengerEscapeHatch", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "withdrawClaimDeposit", values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: "withdrawClaimerEscapeHatch", values: [PromiseOrValue<BigNumberish>]): string;

  decodeFunctionResult(functionFragment: "BURN_ADDRESS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "challenge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "challengePeriod", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "challengers", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "claims", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "depositPlusReward", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "epochAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "epochNow", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "epochPeriod", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isMsgRelayed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "latestVerifiedEpoch", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "resolveDisputedClaim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "routerGnosisToArb", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sendMessage", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sequencerDelayLimit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sequencerFutureLimit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stateRoot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "timeoutEpochs", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "timestampDelayUpdated", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "timestampFutureUpdated", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "updateSequencerDelayLimit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "updateSequencerFutureLimit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verifySnapshot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdrawChallengeDeposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdrawChallengerEscapeHatch", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdrawClaimDeposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdrawClaimerEscapeHatch", data: BytesLike): Result;

  events: {
    "Challenged(uint256,address)": EventFragment;
    "Claimed(address,uint256,bytes32)": EventFragment;
    "MessageRelayed(uint64)": EventFragment;
    "Verified(uint256)": EventFragment;
    "sequencerDelayLimitUpdateReceived(uint256)": EventFragment;
    "sequencerFutureLimitUpdateReceived(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Challenged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Claimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MessageRelayed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Verified"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "sequencerDelayLimitUpdateReceived"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "sequencerFutureLimitUpdateReceived"): EventFragment;
}

export interface ChallengedEventObject {
  _epoch: BigNumber;
  _challenger: string;
}
export type ChallengedEvent = TypedEvent<[BigNumber, string], ChallengedEventObject>;

export type ChallengedEventFilter = TypedEventFilter<ChallengedEvent>;

export interface ClaimedEventObject {
  _claimer: string;
  _epoch: BigNumber;
  _stateRoot: string;
}
export type ClaimedEvent = TypedEvent<[string, BigNumber, string], ClaimedEventObject>;

export type ClaimedEventFilter = TypedEventFilter<ClaimedEvent>;

export interface MessageRelayedEventObject {
  _msgId: BigNumber;
}
export type MessageRelayedEvent = TypedEvent<[BigNumber], MessageRelayedEventObject>;

export type MessageRelayedEventFilter = TypedEventFilter<MessageRelayedEvent>;

export interface VerifiedEventObject {
  _epoch: BigNumber;
}
export type VerifiedEvent = TypedEvent<[BigNumber], VerifiedEventObject>;

export type VerifiedEventFilter = TypedEventFilter<VerifiedEvent>;

export interface sequencerDelayLimitUpdateReceivedEventObject {
  _newSequencerDelayLimit: BigNumber;
}
export type sequencerDelayLimitUpdateReceivedEvent = TypedEvent<
  [BigNumber],
  sequencerDelayLimitUpdateReceivedEventObject
>;

export type sequencerDelayLimitUpdateReceivedEventFilter = TypedEventFilter<sequencerDelayLimitUpdateReceivedEvent>;

export interface sequencerFutureLimitUpdateReceivedEventObject {
  _newSequencerFutureLimit: BigNumber;
}
export type sequencerFutureLimitUpdateReceivedEvent = TypedEvent<
  [BigNumber],
  sequencerFutureLimitUpdateReceivedEventObject
>;

export type sequencerFutureLimitUpdateReceivedEventFilter = TypedEventFilter<sequencerFutureLimitUpdateReceivedEvent>;

export interface VeaOutboxGnosisToArb extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: VeaOutboxGnosisToArbInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    BURN_ADDRESS(overrides?: CallOverrides): Promise<[string]>;

    burn(overrides?: CallOverrides): Promise<[BigNumber]>;

    challenge(
      _epoch: PromiseOrValue<BigNumberish>,
      _disputedStateRoot: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    challengePeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    challengers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[string]>;

    claim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claims(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, number, number] & {
        stateRoot: string;
        claimer: string;
        timestamp: number;
        honest: number;
      }
    >;

    deposit(overrides?: CallOverrides): Promise<[BigNumber]>;

    depositPlusReward(overrides?: CallOverrides): Promise<[BigNumber]>;

    epochAt(
      timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { epoch: BigNumber }>;

    epochNow(overrides?: CallOverrides): Promise<[BigNumber] & { epoch: BigNumber }>;

    epochPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    isMsgRelayed(
      _msgId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isRelayed: boolean }>;

    latestVerifiedEpoch(overrides?: CallOverrides): Promise<[BigNumber]>;

    resolveDisputedClaim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    routerGnosisToArb(overrides?: CallOverrides): Promise<[string]>;

    sendMessage(
      _proof: PromiseOrValue<BytesLike>[],
      _msgId: PromiseOrValue<BigNumberish>,
      _to: PromiseOrValue<string>,
      _message: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sequencerDelayLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    sequencerFutureLimit(overrides?: CallOverrides): Promise<[BigNumber]>;

    stateRoot(overrides?: CallOverrides): Promise<[string]>;

    timeoutEpochs(overrides?: CallOverrides): Promise<[BigNumber]>;

    timestampDelayUpdated(overrides?: CallOverrides): Promise<[BigNumber]>;

    timestampFutureUpdated(overrides?: CallOverrides): Promise<[BigNumber]>;

    updateSequencerDelayLimit(
      _newSequencerDelayLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateSequencerFutureLimit(
      _newSequencerFutureLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verifySnapshot(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawChallengeDeposit(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawChallengerEscapeHatch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawClaimDeposit(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawClaimerEscapeHatch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  BURN_ADDRESS(overrides?: CallOverrides): Promise<string>;

  burn(overrides?: CallOverrides): Promise<BigNumber>;

  challenge(
    _epoch: PromiseOrValue<BigNumberish>,
    _disputedStateRoot: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  challengePeriod(overrides?: CallOverrides): Promise<BigNumber>;

  challengers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

  claim(
    _epoch: PromiseOrValue<BigNumberish>,
    _stateRoot: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claims(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, string, number, number] & {
      stateRoot: string;
      claimer: string;
      timestamp: number;
      honest: number;
    }
  >;

  deposit(overrides?: CallOverrides): Promise<BigNumber>;

  depositPlusReward(overrides?: CallOverrides): Promise<BigNumber>;

  epochAt(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  epochNow(overrides?: CallOverrides): Promise<BigNumber>;

  epochPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  isMsgRelayed(_msgId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

  latestVerifiedEpoch(overrides?: CallOverrides): Promise<BigNumber>;

  resolveDisputedClaim(
    _epoch: PromiseOrValue<BigNumberish>,
    _stateRoot: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  routerGnosisToArb(overrides?: CallOverrides): Promise<string>;

  sendMessage(
    _proof: PromiseOrValue<BytesLike>[],
    _msgId: PromiseOrValue<BigNumberish>,
    _to: PromiseOrValue<string>,
    _message: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sequencerDelayLimit(overrides?: CallOverrides): Promise<BigNumber>;

  sequencerFutureLimit(overrides?: CallOverrides): Promise<BigNumber>;

  stateRoot(overrides?: CallOverrides): Promise<string>;

  timeoutEpochs(overrides?: CallOverrides): Promise<BigNumber>;

  timestampDelayUpdated(overrides?: CallOverrides): Promise<BigNumber>;

  timestampFutureUpdated(overrides?: CallOverrides): Promise<BigNumber>;

  updateSequencerDelayLimit(
    _newSequencerDelayLimit: PromiseOrValue<BigNumberish>,
    _timestamp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateSequencerFutureLimit(
    _newSequencerFutureLimit: PromiseOrValue<BigNumberish>,
    _timestamp: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verifySnapshot(
    _epoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawChallengeDeposit(
    _epoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawChallengerEscapeHatch(
    _epoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawClaimDeposit(
    _epoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawClaimerEscapeHatch(
    _epoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    BURN_ADDRESS(overrides?: CallOverrides): Promise<string>;

    burn(overrides?: CallOverrides): Promise<BigNumber>;

    challenge(
      _epoch: PromiseOrValue<BigNumberish>,
      _disputedStateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    challengePeriod(overrides?: CallOverrides): Promise<BigNumber>;

    challengers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<string>;

    claim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    claims(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, number, number] & {
        stateRoot: string;
        claimer: string;
        timestamp: number;
        honest: number;
      }
    >;

    deposit(overrides?: CallOverrides): Promise<BigNumber>;

    depositPlusReward(overrides?: CallOverrides): Promise<BigNumber>;

    epochAt(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochNow(overrides?: CallOverrides): Promise<BigNumber>;

    epochPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    isMsgRelayed(_msgId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;

    latestVerifiedEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    resolveDisputedClaim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    routerGnosisToArb(overrides?: CallOverrides): Promise<string>;

    sendMessage(
      _proof: PromiseOrValue<BytesLike>[],
      _msgId: PromiseOrValue<BigNumberish>,
      _to: PromiseOrValue<string>,
      _message: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    sequencerDelayLimit(overrides?: CallOverrides): Promise<BigNumber>;

    sequencerFutureLimit(overrides?: CallOverrides): Promise<BigNumber>;

    stateRoot(overrides?: CallOverrides): Promise<string>;

    timeoutEpochs(overrides?: CallOverrides): Promise<BigNumber>;

    timestampDelayUpdated(overrides?: CallOverrides): Promise<BigNumber>;

    timestampFutureUpdated(overrides?: CallOverrides): Promise<BigNumber>;

    updateSequencerDelayLimit(
      _newSequencerDelayLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateSequencerFutureLimit(
      _newSequencerFutureLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    verifySnapshot(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdrawChallengeDeposit(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdrawChallengerEscapeHatch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdrawClaimDeposit(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    withdrawClaimerEscapeHatch(_epoch: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "Challenged(uint256,address)"(
      _epoch?: PromiseOrValue<BigNumberish> | null,
      _challenger?: PromiseOrValue<string> | null
    ): ChallengedEventFilter;
    Challenged(
      _epoch?: PromiseOrValue<BigNumberish> | null,
      _challenger?: PromiseOrValue<string> | null
    ): ChallengedEventFilter;

    "Claimed(address,uint256,bytes32)"(
      _claimer?: PromiseOrValue<string> | null,
      _epoch?: PromiseOrValue<BigNumberish> | null,
      _stateRoot?: null
    ): ClaimedEventFilter;
    Claimed(
      _claimer?: PromiseOrValue<string> | null,
      _epoch?: PromiseOrValue<BigNumberish> | null,
      _stateRoot?: null
    ): ClaimedEventFilter;

    "MessageRelayed(uint64)"(_msgId?: null): MessageRelayedEventFilter;
    MessageRelayed(_msgId?: null): MessageRelayedEventFilter;

    "Verified(uint256)"(_epoch?: PromiseOrValue<BigNumberish> | null): VerifiedEventFilter;
    Verified(_epoch?: PromiseOrValue<BigNumberish> | null): VerifiedEventFilter;

    "sequencerDelayLimitUpdateReceived(uint256)"(
      _newSequencerDelayLimit?: null
    ): sequencerDelayLimitUpdateReceivedEventFilter;
    sequencerDelayLimitUpdateReceived(_newSequencerDelayLimit?: null): sequencerDelayLimitUpdateReceivedEventFilter;

    "sequencerFutureLimitUpdateReceived(uint256)"(
      _newSequencerFutureLimit?: null
    ): sequencerFutureLimitUpdateReceivedEventFilter;
    sequencerFutureLimitUpdateReceived(_newSequencerFutureLimit?: null): sequencerFutureLimitUpdateReceivedEventFilter;
  };

  estimateGas: {
    BURN_ADDRESS(overrides?: CallOverrides): Promise<BigNumber>;

    burn(overrides?: CallOverrides): Promise<BigNumber>;

    challenge(
      _epoch: PromiseOrValue<BigNumberish>,
      _disputedStateRoot: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    challengePeriod(overrides?: CallOverrides): Promise<BigNumber>;

    challengers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    claim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claims(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    deposit(overrides?: CallOverrides): Promise<BigNumber>;

    depositPlusReward(overrides?: CallOverrides): Promise<BigNumber>;

    epochAt(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    epochNow(overrides?: CallOverrides): Promise<BigNumber>;

    epochPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    isMsgRelayed(_msgId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    latestVerifiedEpoch(overrides?: CallOverrides): Promise<BigNumber>;

    resolveDisputedClaim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    routerGnosisToArb(overrides?: CallOverrides): Promise<BigNumber>;

    sendMessage(
      _proof: PromiseOrValue<BytesLike>[],
      _msgId: PromiseOrValue<BigNumberish>,
      _to: PromiseOrValue<string>,
      _message: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sequencerDelayLimit(overrides?: CallOverrides): Promise<BigNumber>;

    sequencerFutureLimit(overrides?: CallOverrides): Promise<BigNumber>;

    stateRoot(overrides?: CallOverrides): Promise<BigNumber>;

    timeoutEpochs(overrides?: CallOverrides): Promise<BigNumber>;

    timestampDelayUpdated(overrides?: CallOverrides): Promise<BigNumber>;

    timestampFutureUpdated(overrides?: CallOverrides): Promise<BigNumber>;

    updateSequencerDelayLimit(
      _newSequencerDelayLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateSequencerFutureLimit(
      _newSequencerFutureLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verifySnapshot(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawChallengeDeposit(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawChallengerEscapeHatch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawClaimDeposit(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawClaimerEscapeHatch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    BURN_ADDRESS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    burn(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    challenge(
      _epoch: PromiseOrValue<BigNumberish>,
      _disputedStateRoot: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    challengePeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    challengers(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claims(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    depositPlusReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochAt(timestamp: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochNow(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    epochPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isMsgRelayed(_msgId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    latestVerifiedEpoch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolveDisputedClaim(
      _epoch: PromiseOrValue<BigNumberish>,
      _stateRoot: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    routerGnosisToArb(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sendMessage(
      _proof: PromiseOrValue<BytesLike>[],
      _msgId: PromiseOrValue<BigNumberish>,
      _to: PromiseOrValue<string>,
      _message: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sequencerDelayLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sequencerFutureLimit(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    stateRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    timeoutEpochs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    timestampDelayUpdated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    timestampFutureUpdated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateSequencerDelayLimit(
      _newSequencerDelayLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateSequencerFutureLimit(
      _newSequencerFutureLimit: PromiseOrValue<BigNumberish>,
      _timestamp: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verifySnapshot(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawChallengeDeposit(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawChallengerEscapeHatch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawClaimDeposit(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawClaimerEscapeHatch(
      _epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
